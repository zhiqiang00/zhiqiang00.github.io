<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>hahahaha哈士奇</title>
  <icon>https://www.gravatar.com/avatar/466f864d3ea0d479eeb340cb0000cda6</icon>
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2022-04-15T08:01:20.816Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>Wangzhiqiang</name>
    <email>1941686805@qq.com</email>
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>使用外网ip连接服务器</title>
    <link href="http://example.com/2022/04/15/%E4%BD%BF%E7%94%A8%E5%A4%96%E7%BD%91ip%E8%BF%9E%E6%8E%A5%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    <id>http://example.com/2022/04/15/%E4%BD%BF%E7%94%A8%E5%A4%96%E7%BD%91ip%E8%BF%9E%E6%8E%A5%E6%9C%8D%E5%8A%A1%E5%99%A8/</id>
    <published>2022-04-15T03:04:51.944Z</published>
    <updated>2022-04-15T08:01:20.816Z</updated>
    
    <content type="html"><![CDATA[<h2 id="使用外网ip连接服务器">使用外网ip连接服务器</h2><h2 id="问题背景">问题背景</h2><p>实验室的服务器没有和和学校申请固定的外网 <code>ip</code> ，导致在服务器使用ppp拨号连接互联网的时候，即使连接了学校里面的校园 <code>wifi</code> 依然无法连接到服务器，而在学校外面连接VPN更是不行，只能通过连接网线的方式使用。这是很痛苦的事情，因为不连互联网就无法下载包，连接了就连接不到网络。就在刚刚突然想起来一个方法，可以暂时解决和这个问题。</p><p>解决方案：</p><p>直接连接服务器的外网 <code>ip</code></p><p>输入命令 <code>ifconfig</code>，找到ppp，如图，然后就可以使用wifi连接了。</p><p><img src="https://raw.githubusercontent.com/zhiqiang00/Picbed/main/blog-images/2022/04/15/297cf9d6188d23a822573885da3e300f-image-20220415110246270-115cc5.png" alt="image-20220415110246270"></p><h2 id="缺点：">缺点：</h2><ul><li>外网 <code>ip</code> 可能不稳定，有可能因为关机等问题发生改变；</li><li>还没有尝试校外VPN是否有效，但是理论上应该可以；</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;使用外网ip连接服务器&quot;&gt;使用外网ip连接服务器&lt;/h2&gt;
&lt;h2 id=&quot;问题背景&quot;&gt;问题背景&lt;/h2&gt;
&lt;p&gt;实验室的服务器没有和和学校申请固定的外网 &lt;code&gt;ip&lt;/code&gt; ，导致在服务器使用ppp拨号连接互联网的时候，即使连接了学校里面的校园 &lt;c</summary>
      
    
    
    
    <category term="linux" scheme="http://example.com/categories/linux/"/>
    
    
    <category term="linux" scheme="http://example.com/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>Git-标签管理</title>
    <link href="http://example.com/2022/04/14/Git-%E6%A0%87%E7%AD%BE%E7%AE%A1%E7%90%86/"/>
    <id>http://example.com/2022/04/14/Git-%E6%A0%87%E7%AD%BE%E7%AE%A1%E7%90%86/</id>
    <published>2022-04-14T02:53:55.017Z</published>
    <updated>2022-04-14T06:26:09.061Z</updated>
    
    <content type="html"><![CDATA[<h2 id="标签管理">标签管理</h2><p>发布一个版本时，我们通常先在版本库中打一个标签（tag），这样，就唯一确定了打标签时刻的版本。将来无论什么时候，取某个标签的版本，就是把那个打标签的时刻的历史版本取出来。所以，标签也是版本库的一个快照。</p><p>Git的标签虽然是版本库的快照，但其实它就是指向某个commit的指针（跟分支很像对不对？但是分支可以移动，标签不能移动），所以，创建和删除标签都是瞬间完成的。</p><p>tag就是一个让人容易记住的有意义的名字，它跟某个commit绑在一起。</p><h3 id="创建标签">创建标签</h3><p>切换到需要打标签的分支，敲命令<code>git tag &lt;name&gt;</code>就可以打一个新标签：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git tag v1.0</span><br></pre></td></tr></table></figure><p>可以用命令<code>git tag</code>查看所有标签：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git tag</span><br><span class="line">v1.0</span><br></pre></td></tr></table></figure><p>默认标签是打在最新提交的commit上的。有时候，如果忘了打标签，比如，现在已经是周五了，但应该在周一打的标签没有打，怎么办？</p><p>方法是找到历史提交的commit id，然后打上就可以了：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ git log --pretty=oneline --abbrev-commit</span><br><span class="line">a70aa75 (HEAD -&gt; dev, tag: v1.0, origin/main, origin/dev, main) conflict fixed</span><br><span class="line">b33a7d9 main</span><br><span class="line">c28d724 feature</span><br><span class="line">f2edd24 &amp; simple</span><br><span class="line">68e9b13 AND simple</span><br><span class="line">b6ea9c3 branch test</span><br><span class="line">a3158c5 remove test.txt</span><br><span class="line">f57c096 add test.txt</span><br><span class="line">dfed0cf git tracks changes</span><br><span class="line">65b2fa1 append GPL</span><br><span class="line">6cd35de 修改readme</span><br><span class="line">b2fe4ff wrote a readme file</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git tag v0.9 c28d724</span><br><span class="line"></span><br><span class="line">$ git tag</span><br><span class="line">v0.9</span><br><span class="line">v1.0</span><br></pre></td></tr></table></figure><p>注意，标签不是按时间顺序列出，而是按字母排序的。可以用<code>git show &lt;tagname&gt;</code>查看标签信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">$ git show v0.9</span><br><span class="line">commit c28d724d4fdc8515c3993900df166db1ef031e41 (tag: v0.9)</span><br><span class="line">Author: zhiqiang00 &lt;1941686805@qq.com&gt;</span><br><span class="line">Date:   Sat Apr 9 17:50:00 2022 +0800</span><br><span class="line"></span><br><span class="line">    feature</span><br><span class="line"></span><br><span class="line">diff --git a/readme.txt b/readme.txt</span><br><span class="line">index 855483a..3d1a029 100644</span><br><span class="line">--- a/readme.txt</span><br><span class="line">+++ b/readme.txt</span><br><span class="line">@@ -2,4 +2,4 @@ Git is a distributed version control system.</span><br><span class="line"> Git is free software distributed under the GPL.</span><br><span class="line"> Git has a mutable index called stage.</span><br><span class="line"> Git tracks changes.</span><br><span class="line">-Creating a new branch is quick AND simple.</span><br><span class="line">\ No newline at end of file</span><br><span class="line">+Creating a new branch is quick &amp; simple. feature1</span><br><span class="line">\ No newline at end of file</span><br></pre></td></tr></table></figure><p>还可以创建带有说明的标签，用<code>-a</code>指定标签名，<code>-m</code>指定说明文字：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git tag -a v0.1 -m &quot;version 0.1 released&quot; 1094adb</span><br></pre></td></tr></table></figure><p>用命令<code>git show &lt;tagname&gt;</code>可以看到说明文字。</p><p><strong>标签是指向commit的死指针，分支是指向commit的活指针</strong></p><h3 id="操作标签">操作标签</h3><p>如果标签打错了，也可以删除：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git tag -d v1.0</span><br><span class="line">Deleted tag &#x27;v1.0&#x27; (was a70aa75)</span><br></pre></td></tr></table></figure><p>因为创建的标签都只存储在本地，不会自动推送到远程。所以，打错的标签可以在本地安全删除。</p><p>如果要推送某个标签到远程，使用命令<code>git push origin &lt;tagname&gt;</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin v0.9</span><br><span class="line">Total 0 (delta 0), reused 0 (delta 0), pack-reused 0</span><br><span class="line">To https://github.com/zhiqiang00/learngit.git</span><br><span class="line"> * [new tag]         v0.9 -&gt; v0.9</span><br></pre></td></tr></table></figure><p>或者，一次性推送全部尚未推送到远程的本地标签：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin --tags</span><br></pre></td></tr></table></figure><p>如果标签已经推送到远程，要删除远程标签就麻烦一点，先从本地删除：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git tag -d v0.9</span><br><span class="line">Deleted tag &#x27;v0.9&#x27; (was c28d724)</span><br></pre></td></tr></table></figure><p>然后，从远程删除。删除命令也是push，但是格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin :refs/tags/v0.9</span><br><span class="line">To https://github.com/zhiqiang00/learngit.git</span><br><span class="line"> - [deleted]         v0.9</span><br></pre></td></tr></table></figure><p>要看看是否真的从远程库删除了标签，可以登陆GitHub查看。</p><p>还可以可以使用<code>git push origin -d tagName</code></p><p>也可以 <code>git push origin -d tag tagName</code></p><p>但是如果远程分支名和标签名重名,那么第一种就会报一个错误,第二种可以指定删除标签。都可以用，标签又不跟分支有联系。即使重名第一种删不了任何东西</p><p><br/><br/><br/></p><h2 id="引用">引用</h2><p>[廖雪峰的官方网站](</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;标签管理&quot;&gt;标签管理&lt;/h2&gt;
&lt;p&gt;发布一个版本时，我们通常先在版本库中打一个标签（tag），这样，就唯一确定了打标签时刻的版本。将来无论什么时候，取某个标签的版本，就是把那个打标签的时刻的历史版本取出来。所以，标签也是版本库的一个快照。&lt;/p&gt;
&lt;p&gt;Git的</summary>
      
    
    
    
    <category term="Git" scheme="http://example.com/categories/Git/"/>
    
    
    <category term="git" scheme="http://example.com/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>LC-617.合并二叉树</title>
    <link href="http://example.com/2022/04/14/LC-617.%E5%90%88%E5%B9%B6%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>http://example.com/2022/04/14/LC-617.%E5%90%88%E5%B9%B6%E4%BA%8C%E5%8F%89%E6%A0%91/</id>
    <published>2022-04-14T02:34:09.281Z</published>
    <updated>2022-04-14T02:34:11.188Z</updated>
    
    <content type="html"><![CDATA[<p>##<a href="https://leetcode-cn.com/problems/merge-two-binary-trees/">LC-617.合并二叉树</a></p><h2 id="递归-先序遍历">递归(先序遍历)</h2><p>变量三步走：</p><ol><li><p><strong>确定递归函数的参数和返回值：</strong></p><p>要合并两个二叉树，所以参数至少传入两个二叉树的根节点，然后返回值就是合并后二叉树的根节点。</p></li><li><p><strong>确定终止条件：</strong></p><p>这里我先给出一个便于理解的版本</p><ul><li>如果两个根节点都不存在，那么 <code>return None</code></li><li>如果 <code>root1</code> 不存在，那么直接返回 <code>root2</code>。这里和链表差不多，一个短的链表被遍历完了，长的链表直接接上就行了，不需要再遍历了，</li><li>同上，如果 <code>root2</code> 不存在，那么直接返回 <code>root1</code></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> root1 <span class="keyword">and</span> <span class="keyword">not</span> root2:</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"><span class="keyword">elif</span> <span class="keyword">not</span> root1:</span><br><span class="line">    <span class="keyword">return</span> root2</span><br><span class="line"><span class="keyword">elif</span> <span class="keyword">not</span> root2:</span><br><span class="line">    <span class="keyword">return</span> root1</span><br></pre></td></tr></table></figure></li><li><p><strong>确定单层递归逻辑：</strong></p><p>如果上面的情况都排除后，那么就一定是两个节点都存在。这时我采用的是新建一个空节点的方法，后面会介绍直接修改两个树中的一个树，这样更节约时间和空间。</p><ul><li>首选创建一个空节点 <code>root</code>；</li><li>同时递归两个根节点的左孩子，然后返回值作为 <code>root</code> 的左孩子；</li><li>同时递归两个根节点的左孩子，然后返回值作为 <code>root</code> 的左孩子；</li></ul></li></ol><p>代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">traverse</span>(<span class="params">self, root1, root2</span>):</span><br><span class="line">        <span class="comment"># 先序遍历</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root1 <span class="keyword">and</span> <span class="keyword">not</span> root2:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">elif</span> <span class="keyword">not</span> root1:</span><br><span class="line">            <span class="keyword">return</span> root2</span><br><span class="line">        <span class="keyword">elif</span> <span class="keyword">not</span> root2:</span><br><span class="line">            <span class="keyword">return</span> root1</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            root = TreeNode(root1.val + root2.val)</span><br><span class="line">            root.left = self.traverse(root1.left, root2.left)</span><br><span class="line">            root.right = self.traverse(root1.right, root2.right)</span><br><span class="line">        <span class="keyword">return</span> root</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">mergeTrees</span>(<span class="params">self, root1: TreeNode, root2: TreeNode</span>) -&gt; TreeNode:</span><br><span class="line">        <span class="keyword">return</span> self.traverse(root1, root2)</span><br></pre></td></tr></table></figure><h2 id="代码优化">代码优化</h2><ul><li><strong>优化1：</strong> 优化递归终止条件，但凡有一个节点为空, 就立刻返回另外一个。如果另外一个也为None也没关系，我们就直接返回None。这样优化以后，就不需要上面那样繁琐的判断过程了。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> root1: <span class="keyword">return</span> root2</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> root2: <span class="keyword">return</span> root1</span><br></pre></td></tr></table></figure><ul><li><strong>优化2：</strong> 经过上面的判断后，<code>root1</code> 和 <code>root2</code> 一定都是非空的。这时候，我们直接修改本来的两课二叉树之一，这里直接改变   <code>root1</code> 的树结构，而不是创建新的节点，这样节省时间和空间。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root1.val += root2.val <span class="comment"># 中</span></span><br><span class="line">root1.left = self.mergeTrees(root1.left, root2.left) <span class="comment">#左</span></span><br><span class="line">root1.right = self.mergeTrees(root1.right, root2.right) <span class="comment"># 右</span></span><br></pre></td></tr></table></figure><h2 id="运行结果：">运行结果：</h2><p>确实快了很多。</p><p><img src="https://raw.githubusercontent.com/zhiqiang00/Picbed/main/blog-images/2022/04/14/85ea2e0927496a2d3243341f0f2441fa-image-20220414103009679-47b013.png" alt="image-20220414103009679"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;##&lt;a href=&quot;https://leetcode-cn.com/problems/merge-two-binary-trees/&quot;&gt;LC-617.合并二叉树&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;递归-先序遍历&quot;&gt;递归(先序遍历)&lt;/h2&gt;
&lt;p&gt;变量三步走：&lt;/p&gt;
&lt;o</summary>
      
    
    
    
    <category term="LeetCode" scheme="http://example.com/categories/LeetCode/"/>
    
    
    <category term="二叉树" scheme="http://example.com/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
    <category term="递归" scheme="http://example.com/tags/%E9%80%92%E5%BD%92/"/>
    
  </entry>
  
  <entry>
    <title>Competition10-全球城市计算AI挑战赛</title>
    <link href="http://example.com/2022/04/13/Competition10-%E5%85%A8%E7%90%83%E5%9F%8E%E5%B8%82%E8%AE%A1%E7%AE%97AI%E6%8C%91%E6%88%98%E8%B5%9B/"/>
    <id>http://example.com/2022/04/13/Competition10-%E5%85%A8%E7%90%83%E5%9F%8E%E5%B8%82%E8%AE%A1%E7%AE%97AI%E6%8C%91%E6%88%98%E8%B5%9B/</id>
    <published>2022-04-13T08:09:01.614Z</published>
    <updated>2022-04-15T02:25:47.297Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Competition10-全球城市计算AI挑战赛">Competition10-全球城市计算AI挑战赛</h2><h2 id="全球城市计算AI挑战赛">全球城市计算AI挑战赛</h2><h2 id="1-赛题理解">1 赛题理解</h2><h2 id="2-数据探索">2 数据探索</h2><h2 id="3-特征工程">3 特征工程</h2><h3 id="数据预处理">数据预处理</h3><p>剔除与测试集数据分布差异较大的数据，比如该赛题中周末和元旦节假日的情况，从而保证整体数据的一致性。</p><h3 id="强相关性特征">强相关性特征</h3><p>强相关性信息主要产生于不同天的同一个时间段，这道题就是使用了前n天相同时间段的进出站流量作为特征。分别构造了10分钟粒度和1小时粒度两个角度。又因为前后时间段流量有波动，又添加了前某个时间段和后某个时间段。也就是说，不仅使用前第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span> 天的相同时间段的数据，还要统计第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span> 天的相同时间段的前一个时间段的数据。</p><h2 id="4-模型训练">4 模型训练</h2><h3 id="4-1-LightGBM">4.1 LightGBM</h3><p>树模型可以反馈重要性得分，由此可以进行特征筛选提取。</p><h3 id="4-2-时序模型">4.2 时序模型</h3><p>训练部分有一个特征重要的参数 <code>shuffle</code> 用于设置每轮(epoch)迭代前是否对数据进行打散操作。 默认为 <code>False</code>。</p><h2 id="5-强化学习">5 强化学习</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Competition10-全球城市计算AI挑战赛&quot;&gt;Competition10-全球城市计算AI挑战赛&lt;/h2&gt;
&lt;h2 id=&quot;全球城市计算AI挑战赛&quot;&gt;全球城市计算AI挑战赛&lt;/h2&gt;
&lt;h2 id=&quot;1-赛题理解&quot;&gt;1 赛题理解&lt;/h2&gt;
&lt;h2 id=&quot;</summary>
      
    
    
    
    <category term="竞赛" scheme="http://example.com/categories/%E7%AB%9E%E8%B5%9B/"/>
    
    
    <category term="特征工程，时间序列" scheme="http://example.com/tags/%E7%89%B9%E5%BE%81%E5%B7%A5%E7%A8%8B%EF%BC%8C%E6%97%B6%E9%97%B4%E5%BA%8F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>LC-106.从中序与后序遍历序列构造二叉树</title>
    <link href="http://example.com/2022/04/13/LC-106.%E4%BB%8E%E4%B8%AD%E5%BA%8F%E4%B8%8E%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>http://example.com/2022/04/13/LC-106.%E4%BB%8E%E4%B8%AD%E5%BA%8F%E4%B8%8E%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91/</id>
    <published>2022-04-13T01:08:29.677Z</published>
    <updated>2022-04-14T02:42:58.963Z</updated>
    
    <content type="html"><![CDATA[<h2 id="LC-106-从中序与后序遍历序列构造二叉树"><a href="https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/">LC-106. 从中序与后序遍历序列构造二叉树</a></h2><p>根据两个顺序构造唯一二叉树的原理：</p><p>以后序数列的最后一个元素为切割点，先切中序数组，根据中序数组反过来切后序数组。一层一层的切下去，最每次后序数组最后一个元素就是节点元素。</p><p><img src="https://raw.githubusercontent.com/zhiqiang00/Picbed/main/blog-images/2022/04/13/211e3b3a4b8ccd7d7d46c2bdef4c7e80-20210203154249860-74909b.png" alt="106.从中序与后序遍历序列构造二叉树"></p><p>来看一下一共分几步：</p><ul><li>第一步：如果数组大小为零的话，说明是空节点了。</li><li>第二步：如果不为空，那么取后序数组最后一个元素作为节点元素。</li><li>第三步：找到后序数组最后一个元素在中序数组的位置，作为切割点</li><li>第四步：切割中序数组，切成中序左数组和中序右数组 （顺序别搞反了，一定是先切中序数组）</li><li>第五步：切割后序数组，切成后序左数组和后序右数组。后序切割是重点，原理是后序分割后的左右数组大小和中序的左右大小应该相同。</li><li>第六步：递归处理左区间和右区间</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">buildTree</span>(<span class="params">self, inorder: <span class="type">List</span>[<span class="built_in">int</span>], postorder: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; TreeNode:</span><br><span class="line">        <span class="comment"># 第一步: 特殊情况讨论: 树为空. (递归终止条件)</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> postorder: </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 第二步: 后序遍历的最后一个就是当前的中间节点. </span></span><br><span class="line">        root_val = postorder[-<span class="number">1</span>]</span><br><span class="line">        root = TreeNode(root_val)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 第三步: 找切割点. </span></span><br><span class="line">        separator_idx = inorder.index(root_val)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 第四步: 切割inorder数组. 得到inorder数组的左,右半边. </span></span><br><span class="line">        inorder_left = inorder[:separator_idx]</span><br><span class="line">        inorder_right = inorder[separator_idx + <span class="number">1</span>:]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 第五步: 切割postorder数组. 得到postorder数组的左,右半边.</span></span><br><span class="line">        <span class="comment"># ⭐️ 重点1: 中序数组大小一定跟后序数组大小是相同的. </span></span><br><span class="line">        postorder_left = postorder[:<span class="built_in">len</span>(inorder_left)]</span><br><span class="line">        postorder_right = postorder[<span class="built_in">len</span>(inorder_left): <span class="built_in">len</span>(postorder) - <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 第六步: 递归</span></span><br><span class="line">        root.left = self.buildTree(inorder_left, postorder_left)</span><br><span class="line">        root.right = self.buildTree(inorder_right, postorder_right)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;LC-106-从中序与后序遍历序列构造二叉树&quot;&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/&quot;&gt;LC-10</summary>
      
    
    
    
    <category term="LeetCode" scheme="http://example.com/categories/LeetCode/"/>
    
    
    <category term="二叉树合并" scheme="http://example.com/tags/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%90%88%E5%B9%B6/"/>
    
  </entry>
  
  <entry>
    <title>Git-分支管理</title>
    <link href="http://example.com/2022/04/09/Git-%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86/"/>
    <id>http://example.com/2022/04/09/Git-%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86/</id>
    <published>2022-04-09T10:00:20.835Z</published>
    <updated>2022-04-14T06:46:50.449Z</updated>
    
    <content type="html"><![CDATA[<h2 id="分支管理">分支管理</h2><h2 id="1-创建与合并分支-这里以-master-为例">1 创建与合并分支(这里以 <code>master</code> 为例)</h2><p>最开始 <code>master</code> 分支只是一条线，Git用 <code>master</code> 指向最新的提交，再用 <code>HEAD</code> 指向 <code>master</code> 。就能确定当前分支以及当前分支的提交点了。</p><p><img src="https://raw.githubusercontent.com/zhiqiang00/Picbed/main/blog-images/2022/04/09/23dd5fde81f65f3896914d84f7f70ce3-image-20220409171302870-73ff25.png" alt="image-20220409171302870"></p><p>每次提交 <code>master</code> 都会向前走一步， <code>master</code> 这个分支的线也会越来越长。</p><p>当我们创建新的分支的时候，例如 <code>dev</code> 时，Git创建一个新的指针叫 <code>dev</code> ，指向 <code>master</code> 相同的提交， 再把 <code>HEAD</code> 指向 <code>dev</code> ，这就表示当前分支在 <code>dev</code> 上。</p><p><img src="https://raw.githubusercontent.com/zhiqiang00/Picbed/main/blog-images/2022/04/09/8fa5a6601e60902d223d4d48240da3d0-image-20220409171556046-8d1e91.png" alt="image-20220409171556046"></p><p>接下来，对工作区的修改和提交就是针对 <code>dev</code> 分支了，比如新提交一次后， <code>dev</code> 指针向前走一步，但是 <code>master</code> 指针不变：</p><p><img src="https://raw.githubusercontent.com/zhiqiang00/Picbed/main/blog-images/2022/04/09/1313d06b70fdadba27f075b73bd21612-image-20220409171734897-0fc171.png" alt="image-20220409171734897"></p><p>当我们在 <code>dev</code> 上完成工作后，通过直接吧 <code>master</code> 指针指向 <code>dev</code> 的当前提交就可以完成 <code>dev</code> 到 <code>master</code> 分支的合并了。</p><p><img src="https://raw.githubusercontent.com/zhiqiang00/Picbed/main/blog-images/2022/04/09/0da6b2de2e3cf5cd5f46aef5ad71c826-image-20220409171942012-2d47b4.png" alt="image-20220409171942012"></p><p>接下来进行实战：</p><ul><li><p>创建 <code>dev</code> 分支，并切换到该分支。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -b dev</span><br><span class="line">Switched to a new branch &#x27;dev&#x27;</span><br></pre></td></tr></table></figure><p><code>git checkout</code> 命令加上 <code>-b</code> 参数表示创建并切换，相当于以下两条命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git branch dev</span><br><span class="line">$ git checkout dev</span><br><span class="line">Switched to branch &#x27;dev&#x27;</span><br></pre></td></tr></table></figure></li><li><p>查看当前分支</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git branch</span><br><span class="line">* dev</span><br><span class="line">  main</span><br></pre></td></tr></table></figure></li><li><p>修改文件，然后提交</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git add readme.txt </span><br><span class="line">$ git commit -m &quot;branch test&quot;</span><br></pre></td></tr></table></figure></li><li><p>然后切换回 <code>main</code> 分支，发现刚刚的修改不见了。</p></li></ul><p><img src="https://raw.githubusercontent.com/zhiqiang00/Picbed/main/blog-images/2022/04/09/0350966ceb81f09f4dcd8c249ec8952a-image-20220409172639033-03cac9.png" alt="image-20220409172639033"></p><ul><li><p>进行分支合并</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git merge dev</span><br><span class="line">Updating a3158c5..b6ea9c3</span><br><span class="line">Fast-forward</span><br><span class="line"> readme.txt | 3 ++-</span><br><span class="line"> 1 file changed, 2 insertions(+), 1 deletion(-)</span><br></pre></td></tr></table></figure><p><code>git merge</code> 命令用于合并指定的分支到<strong>当前分支</strong>。合并后，文件就会相同了。</p><p>注意到上面的<code>Fast-forward</code>信息，Git告诉我们，这次合并是“快进模式”，也就是直接把<code>master</code>指向<code>dev</code>的当前提交，所以合并速度非常快。当然不是每次合并都能 <code>Fast-forward</code> 。</p></li><li><p>合并完成后，就可以删除分支啦</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git branch -d dev</span><br><span class="line">Deleted branch dev (was b6ea9c3).</span><br></pre></td></tr></table></figure></li><li><p><strong>switch</strong></p><p>我们这里使用了 <code>git checkout &lt;branch&gt;</code> 来切换分支，前面讲过的撤销修改则是 <code>git checkout -- &lt;file&gt;</code> ，相同的命令不同的用法有些模糊。最新版本的Git提供了 <code>git switch</code> 命令用来切换分支。</p><p>创建并切换到新的 <code>dev</code> 分支，可以使用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git switch -c dev</span><br></pre></td></tr></table></figure><p>直接切换到已有的<code>master</code>分支，可以使用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git switch main</span><br></pre></td></tr></table></figure></li></ul><h2 id="2-解决冲突">2 解决冲突</h2><p>当我们在不同分支对同一个文件进行修改而进行合并的时候，这种情况下，Git无法执行“快速合并”，只能试图把各自的修改合并起来，但这种合并就可能会有冲突。</p><p><img src="https://raw.githubusercontent.com/zhiqiang00/Picbed/main/blog-images/2022/04/09/2cdaa5944c1f6ef607b5f3ceaa7f5051-image-20220409174157857-0c0f99.png" alt="image-20220409174157857"></p><p>准备新的分支，然后修改 readme.txt， 然后提交。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git switch -c feature1</span><br></pre></td></tr></table></figure><p>切换回 <code>main</code> 分支，然后再修改 readme.txt 的同一行，然后提交。</p><p>我们尝试合并：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git merge feature1</span><br><span class="line">Auto-merging readme.txt</span><br><span class="line">CONFLICT (content): Merge conflict in readme.txt</span><br><span class="line">Automatic merge failed; fix conflicts and then commit the result.</span><br></pre></td></tr></table></figure><p>这是 <code>git status</code> 也会显示冲突。我们这时候查看 readme.txt 文件。</p><p>Git用<code>&lt;&lt;&lt;&lt;&lt;&lt;&lt;</code>，<code>=======</code>，<code>&gt;&gt;&gt;&gt;&gt;&gt;&gt;</code>标记出不同分支的内容，我们将冲突内存删除，保存，然后进行提交。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git add readme.txt</span><br><span class="line">$ git commit -m &quot;conflict fixed&quot;</span><br><span class="line">[main a70aa75] conflict fixed</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/zhiqiang00/Picbed/main/blog-images/2022/04/09/41b0754703d0269c70a5f30bce8e9e34-image-20220409175803838-68a1db.png" alt="image-20220409175803838"></p><p>用带参数的<code>git log</code>也可以看到分支的合并情况：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ git log --graph --pretty=oneline --abbrev-commit</span><br><span class="line">*   a70aa75 (HEAD -&gt; main) conflict fixed</span><br><span class="line">|\</span><br><span class="line">| * c28d724 (feature1) feature</span><br><span class="line">* | b33a7d9 main</span><br><span class="line">* | f2edd24 &amp; simple</span><br><span class="line">|/</span><br><span class="line">* 68e9b13 AND simple</span><br><span class="line">* b6ea9c3 branch test</span><br><span class="line">* a3158c5 (origin/main) remove test.txt</span><br><span class="line">* f57c096 add test.txt</span><br><span class="line">* dfed0cf git tracks changes</span><br><span class="line">* 65b2fa1 append GPL</span><br><span class="line">* 6cd35de 修改readme</span><br><span class="line">* b2fe4ff wrote a readme file</span><br></pre></td></tr></table></figure><p><code>git log --graph</code> 可以查看分支合并图。</p><h4 id="分支管理策略">分支管理策略</h4><p>通常，合并分支的时候 <code>Fast forward</code> 模式，但是这种模式下，删除分支后，会丢掉分支信息。强制禁用 <code>Fast forward</code> 模式，Gi就会在merge时生成一个新的commit，这样，从分支历史就可以看出来分支信息了。</p><p>使用 <code>--no-ff</code> <code>git merge</code>:</p><p>创建并切换 <code>dev</code> 分支：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git switch -c dev</span><br><span class="line">Switched to a new branch &#x27;dev&#x27;</span><br></pre></td></tr></table></figure><p>修改readme.txt文件，并提交一个新的commit：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git commit -m &quot;20220414&quot;</span><br><span class="line">[dev 41f894d] 20220414</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br></pre></td></tr></table></figure><p>切换回 <code>main</code> :</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git switch main</span><br><span class="line">Switched to branch &#x27;main&#x27;</span><br><span class="line">Your branch is ahead of &#x27;origin/main&#x27; by 6 commits.</span><br><span class="line">  (use &quot;git push&quot; to publish your local commits)</span><br></pre></td></tr></table></figure><p>这里的意思是本地仓库比远程 <code>origin/main</code> 提前了6个commit。</p><p>准备合并<code>dev</code>分支，请注意<code>--no-ff</code>参数，表示禁用<code>Fast forward</code>：</p><h3 id="分支策略">分支策略</h3><p>实际开发中，master应该是非常稳定的，应该在 <code>dev</code> 分支上干活，然后合并。团队成员每个人都在 <code>dev</code> 分支上干活，然后时不时的往 <code>dev</code> 分支上合并就可以了。</p><p><img src="https://raw.githubusercontent.com/zhiqiang00/Picbed/main/blog-images/2022/04/14/3fde99592e66bb0030802f7f77bbd57e-0-799174" alt="git-br-policy"></p><h2 id="Bug-分支">Bug 分支</h2><p>软件开发中，bug就像家常便饭一样。有了bug就需要修复，在Git中，由于分支是如此的强大，所以，每个bug都可以通过一个新的临时分支来修复，修复后，合并分支，然后将临时分支删除。</p><p>当你接到一个修复一个代号101的bug的任务时，很自然地，你想创建一个分支<code>issue-101</code>来修复它。</p><h2 id="Feature分支">Feature分支</h2><p>软件开发中，总有无穷无尽的新的功能要不断添加进来。</p><p>添加一个新功能时，你肯定不希望因为一些实验性质的代码，把主分支搞乱了，所以，每添加一个新功能，最好新建一个feature分支，在上面开发，完成后，合并，最后，删除该feature分支。</p><h2 id="多人协作">多人协作</h2><p>当你从远程仓库克隆时，实际上Git自动把本地的<code>master</code>分支和远程的<code>master</code>分支对应起来了，并且，远程仓库的默认名称是<code>origin</code>。</p><p>要查看远程库的信息，用<code>git remote</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git remote</span><br><span class="line">origin</span><br></pre></td></tr></table></figure><p>或者，用<code>git remote -v</code>显示更详细的信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git remote -v</span><br><span class="line">origin  git@github.com:michaelliao/learngit.git (fetch)</span><br><span class="line">origin  git@github.com:michaelliao/learngit.git (push)</span><br></pre></td></tr></table></figure><p>上面显示了可以抓取和推送的<code>origin</code>的地址。如果没有推送权限，就看不到push的地址。</p><h3 id="推送分支">推送分支</h3><p>推送分支，就是把该分支上的所有本地提交推送到远程库。推送时，要指定本地分支，这样，Git就会把该分支推送到远程库对应的远程分支上：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin master</span><br></pre></td></tr></table></figure><p>但是，并不是一定要把本地分支往远程推送，那么，哪些分支需要推送，哪些不需要呢？</p><ul><li><code>master</code>分支是主分支，因此要时刻与远程同步；</li><li><code>dev</code>分支是开发分支，团队所有成员都需要在上面工作，所以也需要与远程同步；</li><li>bug分支只用于在本地修复bug，就没必要推到远程了，除非老板要看看你每周到底修复了几个bug；</li><li>feature分支是否推到远程，取决于你是否和你的小伙伴合作在上面开发。</li></ul><h3 id="抓取分支">抓取分支</h3><p>当合作成员从远程库clone时，默认情况下，你的小伙伴只能看到本地的 <code>main</code> 分支。要在<code>dev</code>分支上开发，就必须创建远程<code>origin</code>的<code>dev</code>分支到本地，于是他用这个命令创建本地<code>dev</code>分支：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -b dev origin/dev</span><br></pre></td></tr></table></figure><h3 id="冲突">冲突</h3><p>多个人同时对相同的文件进行修改，会发生冲突。Git已经提示我们，先用<code>git pull</code>把最新的提交从<code>origin/dev</code>抓下来，然后，在本地合并，解决冲突，再推送。</p><p>如果报错：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ git pull</span><br><span class="line">There is no tracking information for the current branch.</span><br><span class="line">Please specify which branch you want to merge with.</span><br><span class="line">See git-pull(1) for details.</span><br><span class="line"></span><br><span class="line">    git pull &lt;remote&gt; &lt;branch&gt;</span><br><span class="line"></span><br><span class="line">If you wish to set tracking information for this branch you can do so with:</span><br><span class="line"></span><br><span class="line">    git branch --set-upstream-to=origin/&lt;branch&gt; dev</span><br></pre></td></tr></table></figure><p>根据提示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git branch --set-upstream-to=origin/dev dev</span><br><span class="line">Branch &#x27;dev&#x27; set up to track remote branch &#x27;dev&#x27; from &#x27;origin&#x27;.</span><br></pre></td></tr></table></figure><p>设置这个东西，是让你不用每次都git push origin dev , git pull origin dev。关联后可以简化为git pull , git push。</p><p>再 <code>pull</code>，这回<code>git pull</code>成功，但是合并有冲突，需要手动解决，解决的方法和分支管理中的<a href="http://www.liaoxuefeng.com/wiki/896043488029600/900004111093344">解决冲突</a>完全一样。解决后，提交，再push。</p><p><strong>多人协作的工作模式通常是这样：</strong></p><ol><li>首先，可以试图用<code>git push origin &lt;branch-name&gt;</code>推送自己的修改；</li><li>如果推送失败，则因为远程分支比你的本地更新，需要先用<code>git pull</code>试图合并；</li><li>如果合并有冲突，则解决冲突，并在本地提交；</li><li>没有冲突或者解决掉冲突后，再用<code>git push origin &lt;branch-name&gt;</code>推送就能成功！</li></ol><p>如果<code>git pull</code>提示<code>no tracking information</code>，则说明本地分支和远程分支的链接关系没有创建，用命令<code>git branch --set-upstream-to &lt;branch-name&gt; origin/&lt;branch-name&gt;</code>。</p><p><strong>配置Git的时候，加上<code>--global</code>是针对当前用户起作用的，如果不加，那只针对当前的仓库起作用。</strong></p><h4 id="Rebase">Rebase</h4><p>使用频率不高，用时再学。</p><br/><blockquote><p>2022年4月14日  学完了Git的第一遍，我相信还会有第二遍、第三遍~</p></blockquote><p><br/><br/><br/></p><h2 id="引用">引用</h2><p><a href="https://www.liaoxuefeng.com/wiki/896043488029600/896202780297248">廖雪峰的官方网站</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;分支管理&quot;&gt;分支管理&lt;/h2&gt;
&lt;h2 id=&quot;1-创建与合并分支-这里以-master-为例&quot;&gt;1 创建与合并分支(这里以 &lt;code&gt;master&lt;/code&gt; 为例)&lt;/h2&gt;
&lt;p&gt;最开始 &lt;code&gt;master&lt;/code&gt; 分支只是一条线，Git用 </summary>
      
    
    
    
    <category term="Git" scheme="http://example.com/categories/Git/"/>
    
    
    <category term="git" scheme="http://example.com/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>Paper-Guardian-Evaluating Trust in Online Social Networks with Graph Convolutional Networks</title>
    <link href="http://example.com/2022/04/09/Paper-Guardian-Evaluating-Trust-in-Online-Social-Networks-with-Graph-Convolutional-Networks/"/>
    <id>http://example.com/2022/04/09/Paper-Guardian-Evaluating-Trust-in-Online-Social-Networks-with-Graph-Convolutional-Networks/</id>
    <published>2022-04-09T07:53:17.761Z</published>
    <updated>2022-04-10T08:14:59.927Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Guardian-Evaluating-Trust-in-Online-Social-Networks-with-Graph-Convolutional">Guardian: Evaluating Trust in Online Social Networks with Graph Convolutional</h2><h2 id="摘要">摘要</h2><p>在社交网络中，每个用户通常可以一共一个值来表示他们的直接朋友的可信度。推断在线社交网络中任何一对任何一对节点之间的社交信任值是用意义的。</p><p>目前这方面研究的缺点是：</p><ul><li>依赖专业领域知识的手工规则</li><li>需要大量的计算资源，这些问题影响了模型的可扩展性。</li></ul><p>因为GCNs已经在图数据方面表现很好，所以作者使用了GCNs去学习社会信任中的潜在关系。提出了Guardian模型，这个模型欧旨在结合社交网络结构和信任关系来估计任意两个用户之间的社会信任。</p><h2 id="介绍">介绍</h2><p>现有的信任评估方法是基于在线社交网络中<strong>社会信任</strong>的<strong>传播性</strong>和<strong>可组合性</strong>设计的。<strong>社会信任的传播性</strong>指信任可以从一个用户传递给另一个用户，从而创建社会信任链，将两个未明确连接用户连接起来。<strong>社会信任的可组合性</strong>是指如果存在多个社会信任链，则需要聚合信任链。其实，还是信息在网络中的传播和聚合。</p><p>在线社交网络中，社交信任可以类似地表示为图形数据，包括社交网络结构和用户之间相关的信任关系。</p><p>使用图卷积神经网络评估社会信任非常具有挑战性：</p><ul><li>挑战一：如何共同表示社会联系和相关的信任关系，以便能同时捕捉社会信任的传播性和组合性。</li><li>社会信任是不对称的，集一位用户可能对其他人的信任程度超过了对她的信任程度。挑战二：如果表征社会信任中的这种不对称属性。</li></ul><p>该框架的关键组成是信任卷积层，使用了局部图卷积。每一层被学习的参数都在所有用户之间共享，这使得参数的负责程度和输入的图网络大小无关。为了解决不对称的问题，每个信任卷积层都包含两个部分，<strong>流行度信任传播</strong>和<strong>参与度信任传播</strong>。前者用于了解用户对他人的信任程度，后者用于捕捉用户信任他人的意愿。最后通过全连接层。Guardian 能够以协作的方式明确表示个人用户的流行度信任和参与度信任。因此，可以建立有效的成对信任关系。</p><h2 id="问题设置">问题设置</h2><p>在线社交网络可以被定义为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="script">G</mi><mo>=</mo><mo stretchy="false">(</mo><mi mathvariant="script">V</mi><mo separator="true">,</mo><mi mathvariant="script">ε</mi><mo separator="true">,</mo><mi mathvariant="script">W</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\mathcal{G} = (\mathcal {V}, \mathcal \varepsilon, \mathcal W)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7805em;vertical-align:-0.0972em;"></span><span class="mord mathcal" style="margin-right:0.0593em;">G</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathcal" style="margin-right:0.08222em;">V</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">ε</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathcal" style="margin-right:0.08222em;">W</span><span class="mclose">)</span></span></span></span> ，这里面的 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="script">W</mi></mrow><annotation encoding="application/x-tex">\mathcal W</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathcal" style="margin-right:0.08222em;">W</span></span></span></span> 可以理解为信任度，不同的数据集新任务设定不一定。所谓的社会信任评估问题就是去评估(预测)之间没有连接的用户之间的信任度。</p><h2 id="Guardian-模型框架">Guardian 模型框架</h2><p><img src="https://raw.githubusercontent.com/zhiqiang00/Picbed/main/blog-images/2022/04/10/a2e0a6a0cfdf6f4db1bd2c52b10c98f0-image-20220410092224021-8b96ab.png" alt="image-20220410092224021"></p><p>模型由三部分组成：</p><ul><li>嵌入层提供初始的嵌入表示</li><li>多个卷积层，通过引入高阶信息来细调 popularity trust embedding 和 engagement trust embedding，其实就是汇聚更多的信息到初始嵌入表示上。</li><li>全连接层和softmax层组成最后的预测层。它首先将用户的潜在表示转化为信任的潜在因子，然后输出预测的概率</li></ul><p>它首先将用户的潜在表示转化为信任的潜在因子，然后输出预测的概率</p><h3 id="A-Embedding-Layer">A. Embedding Layer</h3><p>作者使用了一个预训练嵌入层将每个user映射到 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>D</mi><mi>e</mi></msub></mrow><annotation encoding="application/x-tex">D_e</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">e</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 维中，值得注意的是，这些表示作为用户嵌入的初始状态，以端到端的方式进行优化。最后经过专门设计的转换层，这些被refine的嵌入向量会被转为成对的向量用于信任度预测。</p><h3 id="B-Trust-Convolutional-Layers">B. Trust Convolutional Layers</h3><p>在线社交网络图包含用户之间的社交联系和信任者与受妥者之间的信任交互，作者提出了一个方法能够同时捕获社交联系和相关信任的关系，从而学习用户嵌入 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>h</mi><mo stretchy="false">[</mo><mi>u</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">h[u]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">h</span><span class="mopen">[</span><span class="mord mathnormal">u</span><span class="mclose">]</span></span></span></span> 。<strong>其实就是不过连接以及权重。</strong></p><p>由于存在不对称性，模型首先将信任交互分为两组： popularity interactions 和 engagement interactions。popularity interactions表明用户被他人信任的程度，而engagement interactions表明用户信任他人的意愿。接下来使用信任卷积层分别聚合信息，表示为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>h</mi><mi>I</mi></msub><mo stretchy="false">[</mo><mi>u</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">h_I[u]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.07847em;">I</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">[</span><span class="mord mathnormal">u</span><span class="mclose">]</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>h</mi><mi>O</mi></msub><mo stretchy="false">[</mo><mi>u</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">h_O[u]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">O</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">[</span><span class="mord mathnormal">u</span><span class="mclose">]</span></span></span></span> 。这里的聚合器使用的是 <code>mean-aggregator</code> 去聚合用户与其邻居相关的信任交互。</p><ul><li><p>Popularity Trust Propagation (pTr)</p><p>传入的社交连接和相关的信任程度提供了该用户受欢迎信任的直接证据，所以基于此进行popularity trust的传播和聚合。使用one-hot编码表示不同类别的可信度，通过公式1映射为稠密的向量。</p><p><img src="https://raw.githubusercontent.com/zhiqiang00/Picbed/main/blog-images/2022/04/10/af66c4d23a730a38925e3e66f2d54053-image-20220410151703756-a9ff95.png" alt="image-20220410151703756"></p><p>建模 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>u</mi></mrow><annotation encoding="application/x-tex">u</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">u</span></span></span></span> 的popularity trust，是需要组合 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi></mrow><annotation encoding="application/x-tex">v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span></span></span></span> 的嵌入表示和他们之间的信任度 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>e</mi><msub><mi>w</mi><mrow><mi>u</mi><mo>←</mo><mi>v</mi></mrow></msub></msub></mrow><annotation encoding="application/x-tex">e_{w_{u \gets v}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6807em;vertical-align:-0.2501em;"></span><span class="mord"><span class="mord mathnormal">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1645em;"><span style="top:-2.357em;margin-left:-0.0269em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">u</span><span class="mrel mtight">←</span><span class="mord mathnormal mtight" style="margin-right:0.03588em;">v</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2501em;"><span></span></span></span></span></span></span></span></span></span> ，如公式2。</p><p><img src="https://raw.githubusercontent.com/zhiqiang00/Picbed/main/blog-images/2022/04/10/40231af11275a1c81a726732c0b7457d-image-20220410152146695-812407.png" alt="image-20220410152146695"></p><p>其中，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⊗</mo></mrow><annotation encoding="application/x-tex">\otimes</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord">⊗</span></span></span></span> 表示两个向量之间的连接操作， <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo fence="true">∣</mo><mi>w</mi><mo fence="true">∣</mo></mrow><annotation encoding="application/x-tex">\left | w \right |</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">∣</span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mclose delimcenter" style="top:0em;">∣</span></span></span></span></span> 表示可信度类型的数量，也就是one-hot的长度。</p><p>取 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">{</mo><mi>p</mi><mi>T</mi><msub><mi>r</mi><mrow><mi>u</mi><mo>←</mo><mi>u</mi></mrow></msub><mo separator="true">,</mo><mi mathvariant="normal">∀</mi><mi>v</mi><mo>∈</mo><msub><mi>N</mi><mi>I</mi></msub><mo stretchy="false">(</mo><mi>u</mi><mo stretchy="false">)</mo><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">\{ pTr_{u \gets u}, \forall v \in N_I(u)\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord mathnormal" style="margin-right:0.13889em;">pT</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">u</span><span class="mrel mtight">←</span><span class="mord mathnormal mtight">u</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">∀</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.109em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.07847em;">I</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">u</span><span class="mclose">)}</span></span></span></span> 里面向量的平均值，这种基于均值的聚合器是局部谱卷积的线性近似，如下函数：</p><p><img src="https://raw.githubusercontent.com/zhiqiang00/Picbed/main/blog-images/2022/04/10/daefb597e7d43208161c9f356998f8d2-image-20220410153319791-a2d263.png" alt="image-20220410153319791"></p></li><li><p>Engagement Trust Propagation (eTr)</p><p>这个聚合和上面的同理。</p><p><img src="https://raw.githubusercontent.com/zhiqiang00/Picbed/main/blog-images/2022/04/10/7f6c76d236caa096158995d4058c91d8-image-20220410153531580-fcda52.png" alt="image-20220410153531580"></p></li><li><p>Learning Trust Latent Factors of Users</p><p>为了更好的进行下游的信任度预测，需要量上面两个方面结合起来，作者通过标准的全连接层将 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>h</mi><mi>I</mi></msub><mo stretchy="false">[</mo><mi>u</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">h_I[u]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.07847em;">I</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">[</span><span class="mord mathnormal">u</span><span class="mclose">]</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>h</mi><mi>O</mi></msub><mo stretchy="false">[</mo><mi>u</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">h_O[u]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">O</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">[</span><span class="mord mathnormal">u</span><span class="mclose">]</span></span></span></span> 结合起来，其中， <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>h</mi><mi>I</mi></msub><mo stretchy="false">[</mo><mi>u</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">h_I[u]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.07847em;">I</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">[</span><span class="mord mathnormal">u</span><span class="mclose">]</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>h</mi><mi>O</mi></msub><mo stretchy="false">[</mo><mi>u</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">h_O[u]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">O</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">[</span><span class="mord mathnormal">u</span><span class="mclose">]</span></span></span></span> 需要先拼接起来。公式如下：</p><p><img src="https://raw.githubusercontent.com/zhiqiang00/Picbed/main/blog-images/2022/04/10/e735140dbc8d725f43371937d4e9e3b4-image-20220410154138536-986931.png" alt="image-20220410154138536"></p></li><li><p>Higher-order Trust Propagation</p><p>通过堆叠  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi></mrow><annotation encoding="application/x-tex">l</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span></span></span></span> 个信任卷积层，用户能够接收从其 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi></mrow><annotation encoding="application/x-tex">l</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span></span></span></span>-hop 邻居传播的社会信任（流行度信任和参与度信任）。在第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi></mrow><annotation encoding="application/x-tex">l</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span></span></span></span> 步中，用户 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>u</mi></mrow><annotation encoding="application/x-tex">u</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">u</span></span></span></span> 的表示递归地表述为等式8-12：</p><p><img src="https://raw.githubusercontent.com/zhiqiang00/Picbed/main/blog-images/2022/04/10/8fee40557cb39c309ba4cc4d4c3a47ad-image-20220410154343706-dc5f89.png" alt="image-20220410154343706"></p><p><img src="https://raw.githubusercontent.com/zhiqiang00/Picbed/main/blog-images/2022/04/10/eda9909e66fdccdb06e564cb4469a530-image-20220410154352106-b051ed.png" alt="image-20220410154352106"></p></li></ul><h3 id="C-Prediction-Layer">C. Prediction Layer</h3><p>为了学习信任关系的潜在因素，我们首先将信任者和受托者的潜在嵌入连接起来，然后将它们拟合到标准的全连接 (FC) 层，然后是 softmax 层。</p><p><img src="https://raw.githubusercontent.com/zhiqiang00/Picbed/main/blog-images/2022/04/10/49e2e6f5432aee518d6f69d46b7f7fc3-image-20220410154813828-b7d650.png" alt="image-20220410154813828"></p><p>从用户 u 的角度来看，用户 v 的可信度计算为 $\widetilde{w}<em>{u \to v} = \mathop{argmax} \limits_j (\widetilde{h}</em>{u \to v}) $ ，这里应该就是将经过激活函数得到的概率向量取其中最大的，就是我们预测的信任度。</p><h3 id="D-Model-Training">D. Model Training</h3><p>为了学习 Guardian 中的模型参数，将目标函数定义为预测值与观察集 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>W</mi></mrow><annotation encoding="application/x-tex">W</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">W</span></span></span></span> 的真实可信度之间的交叉熵损失：</p><p><img src="https://raw.githubusercontent.com/zhiqiang00/Picbed/main/blog-images/2022/04/10/a3682b08bc804598e9049d24d449750e-image-20220410160828081-6ab61b.png" alt="image-20220410160828081"></p><p><img src="https://raw.githubusercontent.com/zhiqiang00/Picbed/main/blog-images/2022/04/10/22c2d28c0f68adff9b4ae45a308b2283-image-20220410161212704-179818.png" alt="image-20220410161212704"></p><h3 id="E-Analysis-and-Discussions">E. Analysis and Discussions</h3><p>Guardian 是一种归纳学习模型，它能够估计在训练阶段未见过的用户的成对可信度。换句话说，它不需要任何重新训练过程，因为预训练的参数可以用于对看不见的用户进行推理。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Guardian-Evaluating-Trust-in-Online-Social-Networks-with-Graph-Convolutional&quot;&gt;Guardian: Evaluating Trust in Online Social Networks w</summary>
      
    
    
    
    <category term="论文阅读" scheme="http://example.com/categories/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/"/>
    
    
    <category term="信任评估" scheme="http://example.com/tags/%E4%BF%A1%E4%BB%BB%E8%AF%84%E4%BC%B0/"/>
    
    <category term="图卷积网络" scheme="http://example.com/tags/%E5%9B%BE%E5%8D%B7%E7%A7%AF%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>Git-远程仓库</title>
    <link href="http://example.com/2022/04/08/Git-%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93/"/>
    <id>http://example.com/2022/04/08/Git-%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93/</id>
    <published>2022-04-08T07:48:37.891Z</published>
    <updated>2022-04-14T02:52:27.539Z</updated>
    
    <content type="html"><![CDATA[<h2 id="远程仓库">远程仓库</h2><h2 id="1-添加远程仓库">1 添加远程仓库</h2><p>如果你已经在本地有一个Git仓库了，邮箱在GitHub创建一个仓库，并且让这个两个仓库进行远程同步。</p><ul><li><p>在GitHub上创建一个新的仓库 <code>learngit</code></p></li><li><p>关联远程仓库</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin https://github.com/zhiqiang00/learngit.git</span><br></pre></td></tr></table></figure><p>其中，远程仓库的名字就是<code>origin</code> ， 这还少Git的默认叫法，这个名字一看就是远程仓库。</p></li><li><p>此时本地仓库的名字是 <code>master</code> ，但是现在GitHub现在主分支已经是 <code>main</code> 了，所以首先修改本地分支名字。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -M main</span><br></pre></td></tr></table></figure><p>一个改名操作，所以本地要保证先有 master 分支，还可以这样 <code>git branch -m oldName  newName</code> 。</p></li><li><p>把本地仓库推送到远程，用 <code>git push</code> 实际是把当前分支 <code>main</code> 推送到远程了。</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push -u origin main</span><br></pre></td></tr></table></figure><p>我们第一次推送 <code>main</code> 的时候，加上了 <code>-u</code> ，不仅会把本地 <code>main</code> 推送到远程新的 <code>main</code> 分支，还会把本地和远程的 <code>main</code> 分支关联起来，这样以后推送或者拉取的时候就会化简命令了。</p><ul><li>之后，只要我们在本地提交了，就可以使用如下命令：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin main</span><br></pre></td></tr></table></figure><h2 id="2-删除远程仓库">2 删除远程仓库</h2><p>可以使用 <code>git remote rm &lt;name&gt;</code> 删除远程仓库。建议先使用 <code>git remote -v</code> 查看远程库信息。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git remote -v</span><br><span class="line">origin  https://github.com/zhiqiang00/learngit.git (fetch)</span><br><span class="line">origin  https://github.com/zhiqiang00/learngit.git (push)</span><br></pre></td></tr></table></figure><p>然后根据返回的名字删除</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote rm origin</span><br></pre></td></tr></table></figure><p>注意，这里只是删除本地和远程的关联关系，而不是删除物理上删除远程仓库。如果要删除远程仓库，还是要登录GitHub删除。</p><h4 id="3-从远程库克隆">3 从远程库克隆</h4><p>区别于上面先有本地仓库，如我们还没有开始项目，最好是先创建远程仓库，然后从远程仓库克隆。</p><p>在创建远程仓库的时候，要勾选 <code>Add a README file</code> 。</p><p><img src="https://raw.githubusercontent.com/zhiqiang00/Picbed/main/blog-images/2022/04/08/5acd1378aa53681d314f5eb16c6a399b-image-20220408161246490-cfc5f0.png" alt="image-20220408161246490"></p><p>然后使用 <code>git clone</code> 克隆到本地。</p><p>GitHub 给出了多个地址，因为Git支持多种协议，默认的 <code>git://</code> 使用ssh，但是也使用 <code>https</code> 。</p><p><br/><br/><br/></p><h2 id="引用">引用</h2><p><a href="https://www.liaoxuefeng.com/wiki/896043488029600/896202780297248">廖雪峰的官方网站</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;远程仓库&quot;&gt;远程仓库&lt;/h2&gt;
&lt;h2 id=&quot;1-添加远程仓库&quot;&gt;1 添加远程仓库&lt;/h2&gt;
&lt;p&gt;如果你已经在本地有一个Git仓库了，邮箱在GitHub创建一个仓库，并且让这个两个仓库进行远程同步。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;在GitHub上创建一个新</summary>
      
    
    
    
    <category term="Git" scheme="http://example.com/categories/Git/"/>
    
    
    <category term="git" scheme="http://example.com/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>Git-时光机穿梭</title>
    <link href="http://example.com/2022/04/06/Git-%E6%97%B6%E5%85%89%E6%9C%BA%E7%A9%BF%E6%A2%AD/"/>
    <id>http://example.com/2022/04/06/Git-%E6%97%B6%E5%85%89%E6%9C%BA%E7%A9%BF%E6%A2%AD/</id>
    <published>2022-04-06T10:14:39.924Z</published>
    <updated>2022-04-08T07:05:00.262Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Git-时光机穿梭">Git-时光机穿梭</h2><p>更该之前提交的readme.txt文件，然后运行 <code>git status</code> 命令查看结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes not staged for commit:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line">  (use &quot;git restore &lt;file&gt;...&quot; to discard changes in working directory)</span><br><span class="line">        modified:   readme.txt</span><br><span class="line"></span><br><span class="line">no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)</span><br></pre></td></tr></table></figure><p><code>git status</code> 用来查看仓库当前的状态。这时只是告诉我们有文件被修改了，可以使用 <code>git diff</code> 命令查看具体改了什么。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ git diff</span><br><span class="line">diff --git a/readme.txt b/readme.txt</span><br><span class="line">index 9f7547c..b18bfcc 100644</span><br><span class="line">--- a/readme.txt</span><br><span class="line">+++ b/readme.txt</span><br><span class="line">@@ -1,2 +1,2 @@</span><br><span class="line">-Git is a version control system.</span><br><span class="line">+Git is a distributed version control system.^M</span><br><span class="line"> Git is free software.</span><br><span class="line">\ No newline at end of file</span><br></pre></td></tr></table></figure><p>通常会显示的格式正是Unix通用的diff格式。</p><p>然后我们输入 <code>git status</code> 和 <code>git commit</code> 并输入 <code>git status</code> 查看状态。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">nothing to commit, working tree clean</span><br></pre></td></tr></table></figure><p>Git告诉我们当前没有需要提交的修改，而且，工作目录是干净（working tree clean）的。</p><h2 id="1-版本回退">1 版本回退</h2><p>再进行一次修改，用来进行验证。</p><p>使用 <code>git log</code> 命令显示从最近到最远的提交日志。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">$ git log</span><br><span class="line">commit 65b2fa1813525287243b334583a3460799c02895 (HEAD -&gt; master)</span><br><span class="line">Author: zhiqiang00 &lt;1941686805@qq.com&gt;</span><br><span class="line">Date:   Wed Apr 6 18:39:32 2022 +0800</span><br><span class="line"></span><br><span class="line">    append GPL</span><br><span class="line"></span><br><span class="line">commit 6cd35de4f4649ab8ad5093bb6cc69eea57858ff4</span><br><span class="line">Author: zhiqiang00 &lt;1941686805@qq.com&gt;</span><br><span class="line">Date:   Wed Apr 6 18:36:36 2022 +0800</span><br><span class="line"></span><br><span class="line">    修改readme</span><br><span class="line"></span><br><span class="line">commit b2fe4fff91ff3a0d22077ede1176eac3d6a9b4a3</span><br><span class="line">Author: zhiqiang00 &lt;1941686805@qq.com&gt;</span><br><span class="line">Date:   Wed Apr 6 11:45:50 2022 +0800</span><br><span class="line"></span><br><span class="line">    wrote a readme file</span><br></pre></td></tr></table></figure><p>如果嫌输出信息太多，看得眼花缭乱的，可以试试加上<code>--pretty=oneline</code>参数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git log --pretty=oneline</span><br><span class="line">65b2fa1813525287243b334583a3460799c02895 (HEAD -&gt; master) append GPL</span><br><span class="line">6cd35de4f4649ab8ad5093bb6cc69eea57858ff4 修改readme</span><br><span class="line">b2fe4fff91ff3a0d22077ede1176eac3d6a9b4a3 wrote a readme file</span><br></pre></td></tr></table></figure><p><strong>准备进行回滚</strong>。首先Git需要知道当前是哪个版本，在Git中head表示当前版本，也就是最近commit的。上一个版本就是<code>HEAD^</code>，上上一个版本就是<code>HEAD^^</code>，当然往上100个版本写100个<code>^</code>比较容易数不过来，所以写成<code>HEAD~100</code>。</p><p>现在把版本回退到上一个版本，使用 <code>git reset</code> :</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ git log</span><br><span class="line">commit 6cd35de4f4649ab8ad5093bb6cc69eea57858ff4 (HEAD -&gt; master)</span><br><span class="line">Author: zhiqiang00 &lt;1941686805@qq.com&gt;</span><br><span class="line">Date:   Wed Apr 6 18:36:36 2022 +0800</span><br><span class="line"></span><br><span class="line">    修改readme</span><br><span class="line"></span><br><span class="line">commit b2fe4fff91ff3a0d22077ede1176eac3d6a9b4a3</span><br><span class="line">Author: zhiqiang00 &lt;1941686805@qq.com&gt;</span><br><span class="line">Date:   Wed Apr 6 11:45:50 2022 +0800</span><br><span class="line"></span><br><span class="line">    wrote a readme file</span><br></pre></td></tr></table></figure><p>可以看到就剩下两个版本了。如果我们想要找回刚刚的那个最新的版本，就需要在命令行窗口还没有被关掉的时候去找到那个 <code>append GPL</code> 的 <code>commit id</code> ，然后指定回到未来的某个版本。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git reset --hard 65b2fa1813525287243b334583a3460799c02895</span><br><span class="line">HEAD is now at 65b2fa1 append GPL</span><br></pre></td></tr></table></figure><p>版本号没必要写全，前几位就可以了，Git会自动去找。当然也不能只写前一两位，因为Git可能会找到多个版本号，就无法确定是哪一个了。</p><p><img src="https://raw.githubusercontent.com/zhiqiang00/Picbed/main/blog-images/2022/04/06/0eb896e060889f6ca1b02758783ac351-image-20220406192748297-80f9ca.png" alt="image-20220406192748297"></p><p>如果窗口已经关了怎么办呢？Git提供了一个命令 <code>git reflog</code> 来记录我们的每一次命令。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git reflog</span><br><span class="line">65b2fa1 (HEAD -&gt; master) HEAD@&#123;0&#125;: reset: moving to 65b2fa1813525287243b334583a3460799c02895</span><br><span class="line">6cd35de HEAD@&#123;1&#125;: reset: moving to HEAD^</span><br><span class="line">65b2fa1 (HEAD -&gt; master) HEAD@&#123;2&#125;: commit: append GPL</span><br><span class="line">6cd35de HEAD@&#123;3&#125;: commit: 修改readme</span><br><span class="line">b2fe4ff HEAD@&#123;4&#125;: commit (initial): wrote a readme file</span><br></pre></td></tr></table></figure><p>这个时候又可以看见 <code>commit id</code> 了，又可以进行向后翻滚了(最新的版本)。</p><h2 id="2-工作去和暂存区">2 工作去和暂存区</h2><ul><li><p>工作区</p><p>就是我们在文件中能看到的目录，即learngit，文件夹就是一个工作区</p></li><li><p>版本库</p><p>工作区里面有 <code>.git</code> 隐藏目录，这个是Git的版本库。</p><p>Git的版本库最重要的两部分就是暂存区stage和暂存区分支master(仓库)，以及指向master的HEAD指针。</p></li></ul><p><img src="https://raw.githubusercontent.com/zhiqiang00/Picbed/main/blog-images/2022/04/07/959063b0157c923ef1bd943d71bca6ff-image-20220407134230971-3d10b5.png" alt="image-20220407134230971"></p><p>我们平时把文件添加到GIt版本库的时候，分两步：</p><ul><li><code>git add</code> 把文件添加到暂存区stage</li><li><code>git commit</code> 实际上是把暂存区的所有内容提交到当前分支。</li></ul><p>其实就是我们平时都是将提交的文件放在暂存区，然后一次性提交暂存区所有修改。</p><p><strong>总结：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Git管理的文件分为：工作区，版本库，版本库又分为暂存区stage和暂存区分支master(仓库)</span><br><span class="line"></span><br><span class="line">工作区&gt;&gt;&gt;&gt;暂存区&gt;&gt;&gt;&gt;仓库</span><br><span class="line"></span><br><span class="line">git add把文件从工作区&gt;&gt;&gt;&gt;暂存区，git commit把文件从暂存区&gt;&gt;&gt;&gt;仓库，</span><br><span class="line"></span><br><span class="line">git diff查看工作区和暂存区差异，</span><br><span class="line"></span><br><span class="line">git diff --cached查看暂存区和仓库差异，</span><br><span class="line"></span><br><span class="line">git diff HEAD 查看工作区和仓库的差异，</span><br><span class="line"></span><br><span class="line">git add的反向命令git checkout，撤销工作区修改，即把暂存区最新版本转移到工作区，</span><br><span class="line"></span><br><span class="line">git commit的反向命令git reset HEAD，就是把仓库最新版本转移到暂存区。</span><br></pre></td></tr></table></figure><h2 id="3-管理修改">3 管理修改</h2><p><strong>Git优秀的地方在于它跟踪并管理的是修改而非文件。</strong></p><ul><li><p>第一次修改 -&gt; <code>git add</code> -&gt; 第二次修改 -&gt; <code>git commit</code> 在这种情况下，第二层修改是不会被commit到分支仓库的。原因是 <code>git add</code> 只会讲工作区的修改存放暂存区。而 <code>git commit</code> 只负责将暂存区的修改提交到分支仓库，而不会直接把工作区的修改提交至分支仓库。</p></li><li><p>提交后，用 <code>git diff HEAD -- readme.txt</code> 命令可以查看工作区和版本库里面最新版本的区别：</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ git diff HEAD -- readme.txt</span><br><span class="line">diff --git a/readme.txt b/readme.txt</span><br><span class="line">index 9da90e9..dce515b 100644</span><br><span class="line">--- a/readme.txt</span><br><span class="line">+++ b/readme.txt</span><br><span class="line">@@ -1,4 +1,4 @@</span><br><span class="line"> Git is a distributed version control system.</span><br><span class="line"> Git is free software distributed under the GPL.</span><br><span class="line"> Git has a mutable index called stage.</span><br><span class="line">-Git tracks changes.</span><br><span class="line">+Git tracks changes of files.</span><br></pre></td></tr></table></figure><p>可见，确实第二次修改没有被提交。</p><h2 id="4-撤销修改">4 撤销修改</h2><h3 id="4-1-写完未-git-add">4.1 写完未 <code>git add</code></h3><p><code>git checkout -- file</code>命令丢弃工作区的修改，也就是  <code>git add</code> 的相反操作，撤销工作区修改，即把暂存区最新版本转移到工作区。命令中的<code>--</code>很重要，没有<code>--</code>，<code>--</code> 和 <code>file</code> 之间有有空格。 就变成了“切换到另一个分支”的命令，我们在后面的分支管理中会再次遇到<code>git checkout</code>命令。</p><h3 id="4-2-已-git-add-了">4.2 已 <code>git add</code> 了</h3><p><code>git reset HEAD &lt;file&gt;</code>命令既可以回退版本，也可以把暂存区的修改回退到工作区。当我们用<code>HEAD</code>时，表示最新的版本。<strong>这时候暂存区是干净的，工作区有修改</strong>。当我们用 <code>HEAD</code> 时，表示最新的版本</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes not staged for commit:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line">  (use &quot;git restore &lt;file&gt;...&quot; to discard changes in working directory)</span><br><span class="line">        modified:   readme.txt</span><br><span class="line"></span><br><span class="line">no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)</span><br></pre></td></tr></table></figure><p>使用 <code>git checkout -- file</code> 命令丢弃工作区的修改</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">nothing to commit, working tree clean</span><br></pre></td></tr></table></figure><p>根据最新的版本，现在有新的命令可以等效替代：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">把工作区的修改撤销： git checkout -- file  ==  git restore [--worktree] file</span><br><span class="line">从暂存区恢复到工作区：git reset HEAD file   ==  git restore --staged file</span><br></pre></td></tr></table></figure><h3 id="4-3-已-git-commit">4.3 已 <code>git commit</code></h3><p>可以版本回退，但是前提是你没有push到远程，如果推送到远程，就真的惨了。</p><h2 id="5-删除文件">5 删除文件</h2><p>创建了一个test.txt文件，然后 <code>git commit</code> 提交。</p><p>使用 <code>rm test.txt</code> 删除test.txt文件，查看状态。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes not staged for commit:</span><br><span class="line">  (use &quot;git add/rm &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line">  (use &quot;git restore &lt;file&gt;...&quot; to discard changes in working directory)</span><br><span class="line">        deleted:    test.txt</span><br><span class="line"></span><br><span class="line">no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)</span><br></pre></td></tr></table></figure><p>这时候有两个选择：</p><ul><li>是确实要从版本库中删除该文件，那就用命令 <code>git rm</code> 删掉，并且 <code>git commit</code> 。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ git rm test.txt</span><br><span class="line">rm &#x27;test.txt&#x27;</span><br><span class="line"></span><br><span class="line">$ git commit -m &quot;remove test.txt&quot;</span><br><span class="line">[master a3158c5] remove test.txt</span><br><span class="line"> 1 file changed, 1 deletion(-)</span><br><span class="line"> delete mode 100644 test.txt</span><br></pre></td></tr></table></figure><ul><li>另一种情况是删错了，因为版本库里还有呢，所以可以把误删的文件恢复到最新版本：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -- test.txt</span><br></pre></td></tr></table></figure><p><code>git checkout</code> 其实是用版本库里的版本替换工作区的版本，无论工作区是修改还是删除，都可以“一键还原”。</p><p>注意：从来没有被添加到版本库就被删除的文件，是无法恢复的！</p><h2 id="引用">引用</h2><p><a href="https://www.liaoxuefeng.com/wiki/896043488029600/896202780297248">廖雪峰的官方网站</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Git-时光机穿梭&quot;&gt;Git-时光机穿梭&lt;/h2&gt;
&lt;p&gt;更该之前提交的readme.txt文件，然后运行 &lt;code&gt;git status&lt;/code&gt; 命令查看结果：&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table</summary>
      
    
    
    
    <category term="Git" scheme="http://example.com/categories/Git/"/>
    
    
    <category term="git" scheme="http://example.com/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>Latex常用公式集合</title>
    <link href="http://example.com/2022/04/06/Latex%E5%B8%B8%E7%94%A8%E5%85%AC%E5%BC%8F%E9%9B%86%E5%90%88/"/>
    <id>http://example.com/2022/04/06/Latex%E5%B8%B8%E7%94%A8%E5%85%AC%E5%BC%8F%E9%9B%86%E5%90%88/</id>
    <published>2022-04-06T06:40:27.335Z</published>
    <updated>2022-04-06T06:55:01.108Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h2 id="limits">\limits</h2><p>\limits可以将它后续跟随的_和^的上下标从右侧转至正上和正下方。需要和 <code>\mathop</code> 配合使用</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>a</mi><mo>=</mo><msub><mi>y</mi><mi>i</mi></msub><mspace linebreak="newline"></mspace><mi>a</mi><mo>=</mo><mover><mo><mi>y</mi></mo><mn>1</mn></mover><mspace linebreak="newline"></mspace><mi>a</mi><mo>=</mo><munder><mo><mi>y</mi></mo><mn>1</mn></munder><mspace linebreak="newline"></mspace></mrow><annotation encoding="application/x-tex">a = y_i \\a = \mathop{y} \limits^{1} \\a = \mathop{y} \limits_{1} \\</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.3761em;vertical-align:-0.0625em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3136em;"><span style="top:-3.1319em;"><span class="pstrut" style="height:3em;"></span><span><span class="mop mathnormal" style="margin-right:0.03588em;">y</span></span></span><span style="top:-3.7625em;margin-left:0.0359em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.0625em;"><span></span></span></span></span></span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.3421em;vertical-align:-0.7796em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.5625em;"><span style="top:-2.3204em;margin-left:-0.0359em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span><span style="top:-3.1319em;"><span class="pstrut" style="height:3em;"></span><span><span class="mop mathnormal" style="margin-right:0.03588em;">y</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.7796em;"><span></span></span></span></span></span></span><span class="mspace newline"></span></span></span></span></p><h2 id="mathop">\mathop</h2><p>\mathop相当于一个定义，在\mathop后的{}内的内容将会被当作一个整体来处理，上下标的位置将会由\mathop的框定范围来决定。注意看 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>θ</mi></mrow><annotation encoding="application/x-tex">\theta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span></span></span></span> 的位置。</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mover accent="true"><mi>θ</mi><mo>ˉ</mo></mover><mo>=</mo><mi>a</mi><mi>r</mi><mi>g</mi><mtext> </mtext><msub><mo><mi>m</mi><mi>a</mi><mi>x</mi></mo><mi>θ</mi></msub><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>N</mi></munderover><mi>s</mi><mi>c</mi><mi>o</mi><mi>r</mi><mi>e</mi><mo stretchy="false">(</mo><msub><mi>y</mi><mi>i</mi></msub><mo separator="true">,</mo><mi>p</mi><mi>r</mi><mi>e</mi><msub><mi>d</mi><mi>i</mi></msub><mo stretchy="false">)</mo><mspace linebreak="newline"></mspace><mover accent="true"><mi>θ</mi><mo>ˉ</mo></mover><mo>=</mo><msub><mo><mi>arg</mi><mo>⁡</mo><mi>min</mi><mo>⁡</mo></mo><mi>θ</mi></msub><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>N</mi></munderover><mi>s</mi><mi>c</mi><mi>o</mi><mi>r</mi><mi>e</mi><mo stretchy="false">(</mo><msub><mi>y</mi><mi>i</mi></msub><mo separator="true">,</mo><mi>p</mi><mi>r</mi><mi>e</mi><msub><mi>d</mi><mi>i</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\bar \theta = arg \ \mathop{max}_{\theta}  \sum^N_{i=1} score(y_i, pred_i) \\\bar \theta = \mathop{\arg\min}_{\theta} \sum^N_{i=1} score(y_i, pred_i)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8312em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8312em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span></span><span style="top:-3.2634em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.1667em;"><span class="mord">ˉ</span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:3.106em;vertical-align:-1.2777em;"></span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mspace"> </span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop"><span class="mop"><span class="mord mathnormal">ma</span><span class="mord mathnormal">x</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">θ</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.8283em;"><span style="top:-1.8723em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.05em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">N</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.2777em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">score</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">p</span><span class="mord mathnormal">re</span><span class="mord"><span class="mord mathnormal">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:0.8312em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8312em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span></span><span style="top:-3.2634em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.1667em;"><span class="mord">ˉ</span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:3.106em;vertical-align:-1.2777em;"></span><span class="mop"><span class="mop"><span class="mop">ar<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop">min</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.242em;"><span style="top:-2.4559em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">θ</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2441em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.8283em;"><span style="top:-1.8723em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.05em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">N</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.2777em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">score</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">p</span><span class="mord mathnormal">re</span><span class="mord"><span class="mord mathnormal">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span></p><h2 id="cdots">\cdots</h2><p>生成位于中间位置的省略号</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi>y</mi><mi>t</mi></msub><mo>=</mo><mfrac><mn>1</mn><mi>N</mi></mfrac><mo stretchy="false">(</mo><msub><mi>w</mi><mn>1</mn></msub><mo>×</mo><msub><mi>y</mi><mrow><mi>t</mi><mo>−</mo><mn>1</mn></mrow></msub><mo>+</mo><msub><mi>w</mi><mn>2</mn></msub><mo>×</mo><msub><mi>y</mi><mrow><mi>t</mi><mo>−</mo><mn>2</mn></mrow></msub><mo>+</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo>+</mo><msub><mi>w</mi><mi>N</mi></msub><mo>×</mo><msub><mi>y</mi><mrow><mi>t</mi><mo>−</mo><mi>N</mi></mrow></msub><mo stretchy="false">)</mo><mspace linebreak="newline"></mspace><msub><mi>y</mi><mi>t</mi></msub><mo>=</mo><mfrac><mn>1</mn><mi>N</mi></mfrac><mo stretchy="false">(</mo><msub><mi>w</mi><mn>1</mn></msub><mo>×</mo><msub><mi>y</mi><mrow><mi>t</mi><mo>−</mo><mn>1</mn></mrow></msub><mo>+</mo><msub><mi>w</mi><mn>2</mn></msub><mo>×</mo><msub><mi>y</mi><mrow><mi>t</mi><mo>−</mo><mn>2</mn></mrow></msub><mo>+</mo><mo>⋯</mo><mo>+</mo><msub><mi>w</mi><mi>N</mi></msub><mo>×</mo><msub><mi>y</mi><mrow><mi>t</mi><mo>−</mo><mi>N</mi></mrow></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">y_t = \frac{1}{N}(w_1 \times y_{t-1} + w_2 \times y_{t-2} + ... +w_N \times y_{t-N})\\y_t = \frac{1}{N}(w_1 \times y_{t-1} + w_2 \times y_{t-2} + \cdots +w_N \times y_{t-N})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2806em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:2.0074em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3214em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0269em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7917em;vertical-align:-0.2083em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">t</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0269em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7917em;vertical-align:-0.2083em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">t</span><span class="mbin mtight">−</span><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord">...</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.0269em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">N</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">t</span><span class="mbin mtight">−</span><span class="mord mathnormal mtight" style="margin-right:0.10903em;">N</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2806em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:2.0074em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3214em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0269em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7917em;vertical-align:-0.2083em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">t</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0269em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7917em;vertical-align:-0.2083em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">t</span><span class="mbin mtight">−</span><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="minner">⋯</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.0269em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">N</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">t</span><span class="mbin mtight">−</span><span class="mord mathnormal mtight" style="margin-right:0.10903em;">N</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h2 id=&quot;limits&quot;&gt;\limits&lt;/h2&gt;
&lt;p&gt;\limits可以将它后续跟随的_和^的上下标从右侧转至正上和正下方。需要和 &lt;code&gt;\mathop&lt;/code&gt; 配合使用&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;katex-disp</summary>
      
    
    
    
    <category term="工具使用" scheme="http://example.com/categories/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/"/>
    
    
    <category term="Latex" scheme="http://example.com/tags/Latex/"/>
    
  </entry>
  
  <entry>
    <title>LC-257. 二叉树的所有路径</title>
    <link href="http://example.com/2022/04/04/LC-257.-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%89%80%E6%9C%89%E8%B7%AF%E5%BE%84/"/>
    <id>http://example.com/2022/04/04/LC-257.-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%89%80%E6%9C%89%E8%B7%AF%E5%BE%84/</id>
    <published>2022-04-04T06:43:25.367Z</published>
    <updated>2022-04-04T07:35:01.268Z</updated>
    
    <content type="html"><![CDATA[<h2 id="LC-257-二叉树的所有路径"><a href="https://leetcode-cn.com/problems/binary-tree-paths/">LC-257. 二叉树的所有路径</a></h2><h2 id="递归法-2">递归法</h2><p>这道题是一个简单题，虽然经过一番思考做了上来，但是确实是思维不清晰，所以还是要总结一下。</p><p>这道题是记录根节点到叶子节点的路径，最重要的是想明白<strong>返回条件</strong>。</p><ul><li><p>这道题是记录到叶子节点，自然是只有到叶子节点的时候，才会返回，也就是说左右子树都不存在的时候 <code>not root.left and not root.right</code>。不要对本层节点进行判断，那样会导致对叶子节点的左右子树判断，最后会同一个路径会添加两次。</p></li><li><p>这道题我采用的时先序遍历，体现在最开始遍历的时候就先把<code>root.val</code>加入到答案中啦~然后才进行的递归。</p></li><li><p>因为上面是判断了一个节点的左右孩子的存在性，没有判断这个节点是否存在，会出现空节点报错，所以在递归的时候，就先应该判断节点是否存在。**重点：**通过传参的时候用+拼接的方式传参，避免了后面还需要回退的问题，这是个小技巧。<strong>也就是说避免了先递归再回溯的问题。</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> root.left: func(root.left, tmp + <span class="string">&#x27;-&gt;&#x27;</span> + <span class="built_in">str</span>(root.left.val))</span><br><span class="line"><span class="keyword">if</span> root.right: func(root.right, tmp + <span class="string">&#x27;-&gt;&#x27;</span> + <span class="built_in">str</span>(root.right.val))</span><br></pre></td></tr></table></figure></li><li><p>有人会好奇，如果没有左右孩子都不存在，那么本层的怎么返回呢？其实不会的，因为别忘记了我们最开始就判断了这个节点是不是叶子节点，如果是叶子节点直接添加，如果不是，则必然一个孩子。</p></li></ul><p>代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">binaryTreePaths</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="built_in">str</span>]:</span><br><span class="line">        res = []</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">root, tmp</span>):</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root.left <span class="keyword">and</span> <span class="keyword">not</span> root.right: </span><br><span class="line">                res.append(tmp)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">if</span> root.left: func(root.left, tmp + <span class="string">&#x27;-&gt;&#x27;</span> + <span class="built_in">str</span>(root.left.val))</span><br><span class="line">            <span class="keyword">if</span> root.right: func(root.right, tmp + <span class="string">&#x27;-&gt;&#x27;</span> + <span class="built_in">str</span>(root.right.val))</span><br><span class="line"></span><br><span class="line">        func(root, <span class="built_in">str</span>(root.val))</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h2 id="迭代法-2">迭代法</h2><p>迭代法依然使用前序遍历的方法。这里的主要思想是需要两个栈，同时讲节点和该节点对应的路径保存。什么叫该节点对一个的路径保存呢，意思就是说到这个节点为止，已经路径到哪了，这样如果它还有孩子直接把 这个路径取出，添加上孩子就好了。</p><p><img src="https://raw.githubusercontent.com/zhiqiang00/Picbed/main/blog-images/2022/04/04/8fe694ddb9ebbb47ffd519dac4bb9270-image-20220404153029677-59ab66.png" alt="image-20220404153029677"></p><p>以示例为了，假如stack[1] = 2，那么path_st[2] = “1-&gt;2”，这样如果到节点5了，只需要取出path_st[2] = &quot;1-&gt;2&quot;加上5，并且5是叶子节点，直接添加到最后的result里面就可以了。</p><p>代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;二叉树的所有路径 迭代法&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">binaryTreePaths</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="type">List</span>[<span class="built_in">str</span>]:</span><br><span class="line">        <span class="comment"># 题目中节点数至少为1</span></span><br><span class="line">        stack, path_st, result = deque([root]), deque(), []</span><br><span class="line">        path_st.append(<span class="built_in">str</span>(root.val))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> stack:</span><br><span class="line">            cur = stack.pop()</span><br><span class="line">            path = path_st.pop()</span><br><span class="line">            <span class="comment"># 如果当前节点为叶子节点，添加路径到结果中</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> (cur.left <span class="keyword">or</span> cur.right):</span><br><span class="line">                result.append(path)</span><br><span class="line">            <span class="keyword">if</span> cur.right:</span><br><span class="line">                stack.append(cur.right)</span><br><span class="line">                path_st.append(path + <span class="string">&#x27;-&gt;&#x27;</span> + <span class="built_in">str</span>(cur.right.val))</span><br><span class="line">            <span class="keyword">if</span> cur.left:</span><br><span class="line">                stack.append(cur.left)</span><br><span class="line">                path_st.append(path + <span class="string">&#x27;-&gt;&#x27;</span> + <span class="built_in">str</span>(cur.left.val))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;LC-257-二叉树的所有路径&quot;&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/binary-tree-paths/&quot;&gt;LC-257. 二叉树的所有路径&lt;/a&gt;&lt;/h2&gt;
&lt;h2 id=&quot;递归法-2&quot;&gt;递归法&lt;/h2&gt;
&lt;p&gt;</summary>
      
    
    
    
    <category term="LeetCode" scheme="http://example.com/categories/LeetCode/"/>
    
    
    <category term="二叉树" scheme="http://example.com/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>Competition09-时间序列</title>
    <link href="http://example.com/2022/04/01/Competition09-%E6%97%B6%E9%97%B4%E5%BA%8F%E5%88%97/"/>
    <id>http://example.com/2022/04/01/Competition09-%E6%97%B6%E9%97%B4%E5%BA%8F%E5%88%97/</id>
    <published>2022-04-01T08:47:31.618Z</published>
    <updated>2022-04-08T07:04:06.005Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-时间序列">1 时间序列</h2><h3 id="1-1-简单定义">1.1 简单定义</h3><p>时间序列是按时间顺序索引的一系列数据点。</p><p>一般基于如下假设：</p><ul><li>数据文件中标签的值表示以等间隔时间进行的连续测量值。</li><li>假设数据存在相关性，然后通过建模找到对应的相关性，并利用它进行预测未来的数据走向。</li></ul><h3 id="1-2-常见问题">1.2 常见问题</h3><ul><li>从变量变量角度，可以分为单变量时间序列和多变量时间序列<ul><li>单变量时间序列指仅具有的单个时间相关变量，所以仅受时间因素的影响。可能受到相关性、趋势性、周期性和循环性等因素的影响。一般该类问题可以看做是多变量时间序列的一部分。</li><li>多变量时间序列具有多个时间相关变量，目标除了受到时间的影响外，还受到了其他因素影响。</li></ul></li><li>从预测目标角度，可以分为单步预测和多步预测<ul><li>单步预测是仅在训练集的时间基础上添加一个时间单位就可以作为测试集。实际上是一个普通回归问题，只不过输入变量不再是独立的特征变量，而是在时间线上有关系。</li><li>多步预测需要多添几个时间单位作为测试集。一般有两种解决方法：<ul><li>第一种，step by step，以单步预测为基础，预测后就作为真实值加入训练集对下一个时间单位进行预测。缺点：误差累加。</li><li>第二种，一次预测出所有时间步的结果，即看做多输出回归问题。这样避免了误差的累加，但是训练一对多的模型，加大了训练难度。、</li></ul></li></ul></li></ul><h3 id="1-3-交叉验证">1.3 交叉验证</h3><p>一般来说为了模型稳定性，我们选择交叉验证。由于时间序列中包含时间结构，在保留这种结构的同时不能在折叠出现数据穿越的情况，使用<strong>滚动交叉验证</strong>。</p><ul><li>思想是，使用初始时间到t时刻用来训练，然后从 t 到 t+n 时刻的数据用于线下验证，并计算批评价指标；</li><li>接下训练数据扩展到 t+n 时刻，然后使用 t+n 到 t+2n时刻的数据进行验证；</li><li>重复上面的步骤，直到达到最后一个标签值。验证次数可以自由控制，多次验证结果取平均值得到最终线下验证结果。</li></ul><h3 id="1-4-基本规则方法">1.4 基本规则方法</h3><p>由于数据中存在噪声或者由于发生了某些突发情况，导致模型不能学习到所有信息，使用规则方法能带来帮助。</p><ul><li><p>加权平均</p><p>加权平均就是先获取最近 N 个时间单位的值，如果数据存在周期性，也可以环比提取，即昨天、上周、上个月对应单位的值；然后将提取出的数据加权求和，通常离当前时间点越近的数据重要程度越高。一般来说，N 值一般考虑短期历史数据。加权平均公式如下：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi>y</mi><mi>t</mi></msub><mo>=</mo><mfrac><mn>1</mn><mi>N</mi></mfrac><mo stretchy="false">(</mo><msub><mi>w</mi><mn>1</mn></msub><mo>×</mo><msub><mi>y</mi><mrow><mi>t</mi><mo>−</mo><mn>1</mn></mrow></msub><mo>+</mo><msub><mi>w</mi><mn>2</mn></msub><mo>×</mo><msub><mi>y</mi><mrow><mi>t</mi><mo>−</mo><mn>2</mn></mrow></msub><mo>+</mo><mo>⋯</mo><mo>+</mo><msub><mi>w</mi><mi>N</mi></msub><mo>×</mo><msub><mi>y</mi><mrow><mi>t</mi><mo>−</mo><mi>N</mi></mrow></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">y_t = \frac{1}{N}(w_1 \times y_{t-1} + w_2 \times y_{t-2} + \cdots +w_N \times y_{t-N})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2806em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:2.0074em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3214em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0269em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7917em;vertical-align:-0.2083em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">t</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0269em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7917em;vertical-align:-0.2083em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">t</span><span class="mbin mtight">−</span><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="minner">⋯</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.0269em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">N</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">t</span><span class="mbin mtight">−</span><span class="mord mathnormal mtight" style="margin-right:0.10903em;">N</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span></p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span> 为当前时间单位的数值。</p><p>对于 N 值得选择和权重的确定是困难的，所以可以通过简单地线性搜索来确定 N 值和权重，线下验证进行最优搜索方式的公式是：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mover accent="true"><mi>θ</mi><mo>ˉ</mo></mover><mo>=</mo><mi>a</mi><mi>r</mi><mi>g</mi><mtext> </mtext><msub><mo><mi>m</mi><mi>a</mi><mi>x</mi></mo><mi>θ</mi></msub><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>N</mi></munderover><mi>s</mi><mi>c</mi><mi>o</mi><mi>r</mi><mi>e</mi><mo stretchy="false">(</mo><msub><mi>y</mi><mi>i</mi></msub><mo separator="true">,</mo><mi>p</mi><mi>r</mi><mi>e</mi><msub><mi>d</mi><mi>i</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\bar \theta = arg \ \mathop{max}_{\theta}  \sum^N_{i=1} score(y_i, pred_i)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8312em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8312em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span></span><span style="top:-3.2634em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.1667em;"><span class="mord">ˉ</span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:3.106em;vertical-align:-1.2777em;"></span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mspace"> </span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop"><span class="mop"><span class="mord mathnormal">ma</span><span class="mord mathnormal">x</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">θ</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.8283em;"><span style="top:-1.8723em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.05em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">N</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.2777em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">score</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">p</span><span class="mord mathnormal">re</span><span class="mord"><span class="mord mathnormal">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span></p></li><li><p>指数平滑</p><p>在时间预测问题中，距离预测单位越近的时间点越重要。将每个时间单位的权重按照指数及进行衰减，并最终进行加权，这种方法称为指数平滑。其公式为：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mover accent="true"><mi>y</mi><mo>^</mo></mover><mi>t</mi></msub><mo>=</mo><mi>a</mi><munderover><mo>∑</mo><mrow><mi>n</mi><mo>=</mo><mn>0</mn></mrow><mi>t</mi></munderover><mo stretchy="false">(</mo><mn>1</mn><mo>−</mo><mi>a</mi><msup><mo stretchy="false">)</mo><mi>n</mi></msup><msub><mi>y</mi><mrow><mi>t</mi><mo>−</mo><mi>n</mi></mrow></msub></mrow><annotation encoding="application/x-tex">\hat y_t = a \sum_{n=0} ^ t (1 -a)^n y_{t - n}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord accent"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.6944em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.1944em;"><span class="mord">^</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.1944em;"><span></span></span></span></span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2806em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:3.0477em;vertical-align:-1.2671em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.7806em;"><span style="top:-1.8829em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mrel mtight">=</span><span class="mord mtight">0</span></span></span></span><span style="top:-3.05em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.2671em;"><span></span></span></span></span></span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">a</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7144em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2806em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">t</span><span class="mbin mtight">−</span><span class="mord mathnormal mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span></span></span></span></span></p><p>其中， <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mover accent="true"><mi>y</mi><mo>^</mo></mover><mi>t</mi></msub></mrow><annotation encoding="application/x-tex">\hat y_t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord accent"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.6944em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.1944em;"><span class="mord">^</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.1944em;"><span></span></span></span></span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2806em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 是第  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi></mrow><annotation encoding="application/x-tex">t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6151em;"></span><span class="mord mathnormal">t</span></span></span></span> 个时间点经过上面指数平滑后得到的值， <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>y</mi><mrow><mi>t</mi><mo>−</mo><mi>n</mi></mrow></msub></mrow><annotation encoding="application/x-tex">y_{t - n}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6389em;vertical-align:-0.2083em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2806em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">t</span><span class="mbin mtight">−</span><span class="mord mathnormal mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span></span></span></span> 为第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mo>−</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">t - n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6984em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">t</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> 个时间点上的实际值，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> 是取当前时刻的前 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> 个历史数据。 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">a</span></span></span></span> 可理解为可调节参数，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>∈</mo><mo stretchy="false">(</mo><mn>0</mn><mo separator="true">,</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">a \in (0, 1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span> ，也称为记忆衰减因子。</p></li></ul><h2 id="2-时间序列模式">2 时间序列模式</h2><h3 id="2-1-趋势性">2.1 趋势性</h3><p>趋势性就是在很长一段时间内呈现数据持续上升或者下降的变动，不仅线性的，周期也可以。一般可以分为一介趋势和二阶趋势进行构造。一阶主要为相邻时间单位的数据分差、比例，反应相邻时间单位数据变化程度；二阶在一阶基础上进一步构建，主要反应一阶变化快慢。</p><h3 id="2-2-周期性">2.2 周期性</h3><p>周期性是指一段时间序列内重复出现的波动，很多时间序列预测问题都存在周期性。</p><p>周期性可以通过环比表现，也就是说周期中相同位置的数据更相似。</p><h3 id="2-3-相关性">2.3 相关性</h3><p>时间序列中的相关性又称为自相关性，描述的是某一段序列存在相关性，这是必然的，否则就无法预测未来了。</p><h3 id="2-4-随机性">2.4 随机性</h3><p>随机性是除了上面三个毛事之外的随机扰动。针对随机性：<strong>(1)</strong> 可以通过简单的异常标注来解决，比如特殊日期、活动； <strong>(2)</strong> 进行预处理，删除异常值。</p><h2 id="3-特征值提取方式">3 特征值提取方式</h2><p>主要围绕时间序列的延迟(历史信息数据)展开，可以分为两类<strong>历史平移</strong>和<strong>窗口统计</strong>两种。还有序列熵特征和额外补充的其他特征。</p><h3 id="3-1-历史平移">3.1 历史平移</h3><p>时间序列数据存在前后关系，比如今天的气温受昨天的影响。也就是说，时间序列中越相近的标签，其相关性越高。借助这个特性构造历史平移特征，即直接将历史记录作为特征。</p><p>具体的，如果当前时刻为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi></mrow><annotation encoding="application/x-tex">t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6151em;"></span><span class="mord mathnormal">t</span></span></span></span> ，那么可以将 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mo>−</mo><mn>1</mn><mtext>、</mtext><mi>t</mi><mo>−</mo><mn>2</mn><mtext>、</mtext><mo>⋯</mo><mi>t</mi><mo>−</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">t - 1 、t - 2、\cdots t - n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6984em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">t</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord">1</span><span class="mord cjk_fallback">、</span><span class="mord mathnormal">t</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord">2</span><span class="mord cjk_fallback">、</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner">⋯</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">t</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> 时刻的值作为特征，这个值可以是标签值，也可以是与标签值存在关联性的值。</p><h3 id="3-2-窗口统计">3.2 窗口统计</h3><p>不同于历史平移从单个序列单位中提取特征，窗口统计是从多个序列单位中提取特征，窗口统计可以反映区间内序列数据的情况。比如最大值、最小值、均值、中位数和方差。窗口大小不固定。</p><h3 id="3-3-序列熵特征">3.3 序列熵特征</h3><p>熵用来反映数据的确定性，用来挖掘数据序列的稳定性，计算公式为：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>e</mi><mi>n</mi><mi>t</mi><mi>r</mi><mi>o</mi><mi>p</mi><mi>y</mi><mo stretchy="false">(</mo><mi>X</mi><mo stretchy="false">)</mo><mo>=</mo><mo>−</mo><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>N</mi></munderover><mi>P</mi><mo stretchy="false">{</mo><mi>x</mi><mo>=</mo><msub><mi>x</mi><mi>i</mi></msub><mo stretchy="false">}</mo><mi>ln</mi><mo>⁡</mo><mi>P</mi><mo stretchy="false">{</mo><mi>x</mi><mo>=</mo><msub><mi>x</mi><mi>i</mi></msub><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">entropy(X) = -\sum^N_{i=1} P\{x=x_i\}\ln P\{x=x_i\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">e</span><span class="mord mathnormal">n</span><span class="mord mathnormal">t</span><span class="mord mathnormal">ro</span><span class="mord mathnormal">p</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:3.106em;vertical-align:-1.2777em;"></span><span class="mord">−</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.8283em;"><span style="top:-1.8723em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.05em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">N</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.2777em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mopen">{</span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">}</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop">ln</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mopen">{</span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">}</span></span></span></span></span></p><p>代码的简单实现：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">import math</span><br><span class="line">import collections</span><br><span class="line">def entropy(nums):</span><br><span class="line">    count = collections.Counter(nums)</span><br><span class="line">    n = len(nums)</span><br><span class="line">    for k,v in count.items():</span><br><span class="line">        count[k] = v / n</span><br><span class="line">    res = 0</span><br><span class="line">    for v in count.values():</span><br><span class="line">      res -= v * math.log(v, 2)</span><br><span class="line">    return res</span><br><span class="line">res1 = entropy([1,2,1,2,1,2,1,2,1,2,1])</span><br><span class="line">res2 = entropy([1,1,2,1,2,2,2,2,1,1,1])</span><br><span class="line">res3 = entropy([1, 2, 1, 2, 1, 2, 1, 2, 1, 2 ])</span><br><span class="line">res4 = entropy([1, 2, 1, 2, 2, 1, 2, 1, 1, 2, 1, 1, 1, 1, 1 ])</span><br><span class="line">res5 = entropy([1, 2, 3, 4, 2, 1, 2, 4, 3, 2, 3, 4, 1, 1, 1 ])</span><br><span class="line">res6 = entropy([1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4 ])</span><br><span class="line"></span><br><span class="line">print(res1, res2,res3, res4,res5, res6)</span><br></pre></td></tr></table></figure><h3 id="3-4-其他特征">3.4 其他特征</h3><p>除了上面三个外，还有很多常用特征，分为两类：</p><ul><li>时间特征：比如小时、天、周，一天中的某个时间段(如上午，下午)，距离某日还有几天，是否为节假日；</li><li>统计特征：基本的统计特征有最大值、最小值、均值、中位数、方差、标准差、偏度、峰值，另外还有一阶差分、二阶差分、比例相关特征。</li></ul><h2 id="4-模型多样性">4 模型多样性</h2><p>一般来说，将以下这些模型都跑一边，首先可以找到好的单模，其实为后面的模型融合做准备。</p><h3 id="4-1-传统的时序模型">4.1 传统的时序模型</h3><p>差分自回归平滑平均模型(<strong>ARIMA</strong>)是一种常见的时序模型。它包括自回归模型（AR），p是自回归系数，移动平均模型（MA），q是移动平均窗口大小，d是成为稳定序列所进行的差分次数；I代表积分，表示数值以被当前值和先前值之间的差值替换(这个微分过程可能已经执行了不止一次)。</p><p>三次指数平滑主要是基于数据趋势性和季节性的描述，而<strong>ARIMA</strong>模型主要<strong>描述的数据之间的相互关系</strong>。它中的三部分的目的就是使模型更加容易拟合历史数据，能够在较大时间范围内获得较高的准确性。</p><ul><li><p><strong>参数确定</strong></p><p>p、d和q均为非负数，首先进行d阶差分，将时间序列数据转换为平稳时间序列，然后分为求得平稳时间序列的ACF图和PACF图，通过这个两个图得到最佳的阶层p和阶数q。</p></li></ul><h3 id="4-2-树模型">4.2 树模型</h3><p>树模型是比较通用的模型，当趋势性和季节性相对稳定，并且噪声较小的时候，树模型是非常合适的。可以通过一些处理来降低时间序列的趋势性，使之变得平稳。</p><p>使时间序列转换为平稳序列的方法有对数处理、一阶差分、季节性差分等。一般而言，先进行平稳性调整，然后进行训练，最后结果再进行转换即可。这三种方法可以单独使用，也可以组合。</p><h3 id="4-3-深度学习模型">4.3 深度学习模型</h3><ul><li>卷积神经网络</li><li>长短期记忆网络</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-时间序列&quot;&gt;1 时间序列&lt;/h2&gt;
&lt;h3 id=&quot;1-1-简单定义&quot;&gt;1.1 简单定义&lt;/h3&gt;
&lt;p&gt;时间序列是按时间顺序索引的一系列数据点。&lt;/p&gt;
&lt;p&gt;一般基于如下假设：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;数据文件中标签的值表示以等间隔时间进行的连续测量值。</summary>
      
    
    
    
    <category term="竞赛" scheme="http://example.com/categories/%E7%AB%9E%E8%B5%9B/"/>
    
    
    <category term="特征工程，时间序列" scheme="http://example.com/tags/%E7%89%B9%E5%BE%81%E5%B7%A5%E7%A8%8B%EF%BC%8C%E6%97%B6%E9%97%B4%E5%BA%8F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>解决服务器端可以使用的命令但是在远程终端无法使用的问题</title>
    <link href="http://example.com/2022/04/01/%E8%A7%A3%E5%86%B3%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E5%8F%AF%E4%BB%A5%E4%BD%BF%E7%94%A8%E7%9A%84%E5%91%BD%E4%BB%A4%E4%BD%86%E6%98%AF%E5%9C%A8%E8%BF%9C%E7%A8%8B%E7%BB%88%E7%AB%AF%E6%97%A0%E6%B3%95%E4%BD%BF%E7%94%A8%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>http://example.com/2022/04/01/%E8%A7%A3%E5%86%B3%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E5%8F%AF%E4%BB%A5%E4%BD%BF%E7%94%A8%E7%9A%84%E5%91%BD%E4%BB%A4%E4%BD%86%E6%98%AF%E5%9C%A8%E8%BF%9C%E7%A8%8B%E7%BB%88%E7%AB%AF%E6%97%A0%E6%B3%95%E4%BD%BF%E7%94%A8%E7%9A%84%E9%97%AE%E9%A2%98/</id>
    <published>2022-04-01T03:48:01.052Z</published>
    <updated>2022-04-01T04:00:58.828Z</updated>
    
    <content type="html"><![CDATA[<h2 id="解决服务器端可以使用的命令但是在远程终端无法使用的问题">解决服务器端可以使用的命令但是在远程终端无法使用的问题</h2><h3 id="问题背景">问题背景</h3><p>最近遇见了一个奇怪的问题，就是明明已经配置好了conda环境并且可以正常使用了。但是最近突然在远程终端无法使用，而在服务器终端却可以使用：</p><p><img src="https://raw.githubusercontent.com/zhiqiang00/Picbed/main/blog-images/2022/04/01/ae5b11b4af4aa34ac08340a02ca4f2db-image-20220401112805048-9cc570.png" alt="image-20220401112805048"></p><p>最开始的解决办法是使用另一个账号作为桥梁，即先使用一个账号登录，然后<code>su</code>进去，这种方式很奇怪，并且觉得出现这个问题的原因应该就是conda的路径问题，但进入到<code>./.bashrc</code>看了一下，路径没有问题。于是开始各种查找资料…</p><h3 id="解决方法">解决方法</h3><p>重新使用终端连接服务器，并在终端中输入<code>source ~/.bashrc</code>。</p><p>推测的原因可能是因为远程终端突然没有了配置路径，虽然服务器那边的conda可用，但是配置路径没有刷新到远程终端。路径刷新成功后，如图会变成绿色：</p><p><img src="https://raw.githubusercontent.com/zhiqiang00/Picbed/main/blog-images/2022/04/01/92efa974d912f5d4963342ca93f2f08e-image-20220401115555314-d25986.png" alt="image-20220401115555314"></p><p>虽然可以通过<code>source ~/.bashrc</code>可以解决，但每次进终端都得这样激活环境变量太过麻烦。</p><p>由于用于每次远程连接服务器端的时候，系统一般会先执行 <code>~/.bash_profile</code> 的配置文件，所以我们可以 <code>vim ~/.bash_profile</code> 打开 <code>~/.bash_profile</code> 配置文件开头添加如下代码(在vim编辑界面中，按 <code>i</code> 后进行插入编辑)：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if test -f .bashrc ; then</span><br><span class="line">source .bashrc </span><br><span class="line">fi</span><br></pre></td></tr></table></figure><p>如图：</p><p><img src="https://raw.githubusercontent.com/zhiqiang00/Picbed/main/blog-images/2022/04/01/d76bb3d3a8c1c10bfb2e5e5311db7cd6-image-20220401115630942-dcd005.png" alt="image-20220401115630942"></p><p><img src="https://raw.githubusercontent.com/zhiqiang00/Picbed/main/blog-images/2022/04/01/d685c05cb64f352e3186835d6168d07a-image-20220401114646129-28b94b.png" alt="image-20220401114646129"></p><p>然后按<code>ESC</code> + <code>:</code> + <code>wq</code> 进行保存退出。最后退出连接并重新进入，即可正常使用 <code>conda</code>命令啦~</p><p><img src="https://raw.githubusercontent.com/zhiqiang00/Picbed/main/blog-images/2022/04/01/785a35dfe5b6c3ba05d3601c2b74e6ba-image-20220401115652422-917c0e.png" alt="image-20220401115652422"></p><p><br />  <br />  <br /></p><blockquote><p><a href="https://blog.csdn.net/qq_43351000?type=blog">欢迎关注我的CSDN个人博客【请叫我哈士奇】~</a></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;解决服务器端可以使用的命令但是在远程终端无法使用的问题&quot;&gt;解决服务器端可以使用的命令但是在远程终端无法使用的问题&lt;/h2&gt;
&lt;h3 id=&quot;问题背景&quot;&gt;问题背景&lt;/h3&gt;
&lt;p&gt;最近遇见了一个奇怪的问题，就是明明已经配置好了conda环境并且可以正常使用了。但是最</summary>
      
    
    
    
    <category term="linux" scheme="http://example.com/categories/linux/"/>
    
    
    <category term="linux" scheme="http://example.com/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>Git-简介</title>
    <link href="http://example.com/2022/03/31/Git-%E7%AE%80%E4%BB%8B/"/>
    <id>http://example.com/2022/03/31/Git-%E7%AE%80%E4%BB%8B/</id>
    <published>2022-03-31T09:50:26.410Z</published>
    <updated>2022-04-06T10:14:27.223Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-Git-简介">1 Git-简介</h2><h3 id="1-1-Git的诞生">1.1 Git的诞生</h3><p>Linus在1991年创建了开源的Linux。Linus最开始是使用Bitkeeper进行版本控制，后来因为社区有人尝试破解Bitkeeper的协议，BitKeeper公司要收回免费使用权。于是，Linus花了两周时间自己用C写了一个分布式版本控制，这就是<strong>Git</strong>。</p><h3 id="1-2-集中式-VS-分布式">1.2 集中式 VS 分布式</h3><ul><li><p><strong>集中式</strong></p><p>集中式版本控制系统，版本库集中存放中央服务器。在干活的时候，需要先从中央服务器取得最新版本，然后开始干活，干完活后再把自己的活推送给中央服务器。集中式最大的毛病就是必须联网才可以。</p><p>所有的版本数据都存在服务器上，用户的本地设备只能看到自己以前所同步的版本，如果不连网的话，用户就看不到历史版本。</p></li></ul><p><img src="https://raw.githubusercontent.com/zhiqiang00/Picbed/main/blog-images/2022/04/06/ac5b0c9152a30aef52c1871194cd4b05-image-20220406105153228-506b89.png" alt="image-20220406105153228"></p><p><img src="https://raw.githubusercontent.com/zhiqiang00/Picbed/main/blog-images/2022/04/06/0f73c49a3f69289c7b533a878f646804-image-20220406110129054-a85b48.png" alt="image-20220406110129054"></p><ul><li><p><strong>分布式</strong></p><p>分布式控制系统中没有“中央服务器”，每个人电脑都是一个完整的版本库。两个人同时修改同一个文件<strong>A</strong>，这是只需要把各自修改的内容推送到对方，就可以相互看到对方的修改了。分布式除了不需要联网外，安全性能要高很多，因为每个人电脑里面都有一个完整版。</p><p>也需要一个“版本集中存放的服务器”，但是这个服务器仅用来方便“交换”修改，没有他一样干活。<strong>而每一台电脑有各自独立的开发环境，不需要联网，本地直接运行，相对集中式安全系数高很多。</strong></p><p>分布式不是复制指定版本的快照，而是把所有的版本信息仓库同步到本地，可以离线本地提交，只有需要联网时push到相应的服务器或者其他用户那里。也就是平时自己<code>git add</code>就是本地，<code>git push</code>就是同步远程。</p></li></ul><p><img src="https://raw.githubusercontent.com/zhiqiang00/Picbed/main/blog-images/2022/04/06/04f91ae7fa2ddf9fe585217bcd1212f2-image-20220406105212046-23c76b.png" alt="image-20220406105212046"></p><p><img src="https://raw.githubusercontent.com/zhiqiang00/Picbed/main/blog-images/2022/04/06/b443a8cfaae5c9f9c308b3149e24611b-image-20220406110720175-db0c3d.png" alt="image-20220406110720175"></p><ul><li><p><strong>区别</strong><br>你的本地是否有完整的版本库历史！<br>假设SVN服务器没了，那你丢掉了所有历史信息，因为你的本地只有当前版本以及部分历史信息。SVN每次都需要联网commit。<br>假设GitHub服务器没了，你不会丢掉任何git历史信息，因为你的本地有完整的版本库信息。你可以把本地的git库重新上传到另外的git服务商。Git只有在Push、pull 的时候需要联网，而我们平时更多的操作应是commit。</p><p>针对分布式，我们平时用git commit的命令就是在自己本地仓库进行版本控制，和远程没关系。只有需要大家一起同步的时，我们才会“随便”找一个大家统一认定的电脑进行同步。也就是说，分布式是“同步原则”，平时自己提交到自己的本地仓库，需要同步的时候，我们进行push同步。即使断网了，让然可以进行版本回滚和更新，因为有完整的版本信息。</p><p>针对集中式，我们本地只有当前版本和部分历史版本，这时候如果断网或者中央服务器挂了，那么所有的历史版本就都没有了，无法回滚版本。每次commit都需要联网，所以无法进行回滚和更新。</p></li></ul><h2 id="2-Git安装">2 Git安装</h2><p>Git是分布式版本控制系统，所以每个机器都必须说明自己的情况：你的名字和Email地址。</p><p>注意<code>git config</code>命令的<code>--global</code>参数，用了这个参数，表示你这台机器上所有的Git仓库都会使用这个配置，当然也可以对某个仓库指定不同的用户名和Email地址。</p><h2 id="3-创建版本库">3 创建版本库</h2><p>所谓版本库(repository)可以理解为一个目录，里面的所有的文件都可以被Git管理起来，能跟踪文件的修改、删除，便于追踪和还原。</p><h3 id="3-1-创建空目录：">3.1 创建空目录：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mkdir learngit</span><br><span class="line">cd learngit</span><br><span class="line">pwd</span><br><span class="line">/d/learngit</span><br></pre></td></tr></table></figure><h3 id="3-2-初始化为IGt可以管理的仓库">3.2 初始化为IGt可以管理的仓库</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git init</span><br><span class="line">Initialized empty Git repository in D:/learngit/.git/</span><br></pre></td></tr></table></figure><p>该目录下面会生成一个<code>.git</code>的目录，用于跟踪和管理版本库。当然，不一定在新的空目录下，有东西的目录也可以初始化为Git仓库。</p><h3 id="3-2-把文件添加到版本库">3.2 把文件添加到版本库</h3><p>首先明确，所有的版本控制系统其实只能跟踪文本文件的改动，比如TXT文件网页和代码等，包括Git，无法跟踪图片、视频等二进制文件，只知道大小改变了，无法知道改了哪里。</p><p>不要使用Windows自带的记事本，原因是Microsoft开发记事本的团队使用在每个文件开头添加了0xefbbbf（十六进制）的字符的方式来保存UTF-8编码的文件，会导致遇到很多不可思议的问题。</p><p>第一步，使用 <code>git add</code> 告诉Git，把文件添加到仓库。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git add readme.txt</span><br></pre></td></tr></table></figure><p>没有输出。</p><p>第二步，使用 <code>git commit</code> 告诉Git，把文件提交到仓库。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git commit -m &quot;wrote a readme file&quot;</span><br></pre></td></tr></table></figure><p><code>git commit</code>命令执行成功后会告诉你，<code>1 file changed</code>：1个文件被改动（我们新添加的readme.txt文件）；<code>2 insertions</code>：插入了两行内容（readme.txt有两行内容）。</p><p><strong>疑难解答：</strong></p><p>Q：输入<code>git add readme.txt</code>，得到错误<code>fatal: pathspec 'readme.txt' did not match any files</code>。</p><p>A：添加某个文件时，该文件必须在当前目录下存在，用<code>ls</code>或者<code>dir</code>命令查看当前目录的文件，看看文件是否存在，或者是否写错了文件名。</p><p><br/><br/><br/></p><h2 id="引用">引用</h2><p><a href="https://www.liaoxuefeng.com/wiki/896043488029600/896202780297248">廖雪峰的官方网站</a></p><p><a href="https://blog.csdn.net/sjt19910311/article/details/83685420?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-1.pc_relevant_paycolumn_v3&amp;spm=1001.2101.3001.4242.2&amp;utm_relevant_index=4">集中式版本控制与分布式版本控制</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-Git-简介&quot;&gt;1 Git-简介&lt;/h2&gt;
&lt;h3 id=&quot;1-1-Git的诞生&quot;&gt;1.1 Git的诞生&lt;/h3&gt;
&lt;p&gt;Linus在1991年创建了开源的Linux。Linus最开始是使用Bitkeeper进行版本控制，后来因为社区有人尝试破解Bitkeep</summary>
      
    
    
    
    <category term="Git" scheme="http://example.com/categories/Git/"/>
    
    
    <category term="git" scheme="http://example.com/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>Paper-A Simple Framework for Contrastive Learning of Visual Representations</title>
    <link href="http://example.com/2022/03/31/Paper-A-Simple-Framework-for-Contrastive-Learning-of-Visual-Representations/"/>
    <id>http://example.com/2022/03/31/Paper-A-Simple-Framework-for-Contrastive-Learning-of-Visual-Representations/</id>
    <published>2022-03-31T09:28:11.698Z</published>
    <updated>2022-04-09T07:51:58.603Z</updated>
    
    <content type="html"><![CDATA[<h2 id="A-Simple-Framework-for-Contrastive-Learning-of-Visual-Representations-SimCLR">A Simple Framework for Contrastive Learning of Visual Representations(SimCLR)</h2><blockquote><p>论文方向：图像领域</p><p>论文来源：2020 International Conference on Machine Learning</p><p>论文链接：<a href="https://arxiv.org/abs/2002.05709">https://arxiv.org/abs/2002.05709</a></p><p>论文代码：<a href="https://github.com/google-research/simclr">https://github.com/google-research/simclr</a></p></blockquote><h2 id="摘要">摘要</h2><p>这篇文介绍了SimCLR，用于视觉表示对比学习的简单框架。这里作者化简最近提出的对比自监督学习算法，不再需要专门的架构和存储库。对于为什么对比学习任务能学到有用的表示，作者们系统的研究了自己的框架，给出以下三个说明：</p><ul><li>数据增强的组合在定义有效任务中有效的预测任务中有着关键作用；</li><li>在表示学习和对比损失之间引入非线性变化大大提高了表示学习的质量；</li><li>对比学习相比于有监督学习，受益于更大的batch sizes和更多的training steps。</li></ul><p>通过上面这些发现，作者能够大大的优化以前在ImageNet上进行自监督和半监督的学习方法。</p><h2 id="1-介绍">1. 介绍</h2><p>在没有人工监督的情况下的学习有效的视觉表示方法是一个长久的问题，一般分类如下两类：生成式(generative)和判别式(discriminative)。生成方法学习在输入空间中生成或以其他方式 建模像素。判别方法使用类似于监督学习的目标函数来学习表示，但训练网络执行网络前置任务（Pretex task的好处就是简化了原任务的求解，在深度学习里就是避免了人工标记样本，实现无监督的语义提取），其中输入和标签都来自未标记的数据集。许多这样的方法依赖于启发式来设计网络前置任务。</p><p>为了了解什么能够实现良好的对比表示学习，作者系统地研究了他们的框架的主要组成部分并表明：</p><ul><li>多多个数据增强操作的组合对于定义产生有效表示的对比预测任务至关重要。同时，无监督的对比学习更受益于更强的数据增强。</li><li>在表示和对比损失之间引入可学习的非线性变换大大提高了学习表示的质量。</li><li>具有对比交叉熵损失的表示学习受益于归一化嵌入和适当的调整温度参数(<a href="https://zhuanlan.zhihu.com/p/132785733">temperature parameter</a>)</li><li>对比学习相比于有监督学习，受益于更大的 batch sizes 和更长时间的训练。并且也更受益于更深更宽的网络。</li></ul><h2 id="2-方法">2. 方法</h2><h3 id="2-1-The-Contrastive-Learning-Framework">2.1 The Contrastive Learning Framework</h3><p>SimCLR 在潜在空间中通过对比损失最大化同一个数据不同增强视图之间的一致性来表示学习。在这个框架下一共包括了四个组件，如图所示：</p><p><img src="https://raw.githubusercontent.com/zhiqiang00/Picbed/main/blog-images/2022/03/31/d5400b85d6a71807b9df6206c02a1389-image-20220331210653510-662af6.png" alt="image-20220331210653510"></p><ul><li>一个随机数据增强模块，他随机转换任何给定数据实例，产生表示同一个示例的两个相关视图，表示为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">x_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">x_j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7167em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span> ，我们将其视为正对(positive pair)。该文章中，作者使用了三个简单的随机这随机增强：随机裁剪，然后将大小调整回原始大小、随机颜色失真和随机高斯模糊。如第 3 节所示，随机裁剪和颜色失真的组合对于获得良好的性能至关重要。</li><li>使用神经网络基础的编码器 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mo>⋅</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(\cdot)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord">⋅</span><span class="mclose">)</span></span></span></span> 从增强数据中提取表示向量。这个框架可以任意选择网络架构，没有限制。该文选择简单，采用常用的 ResNet。 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi mathvariant="bold-italic">h</mi><mi>i</mi></msub><mo>=</mo><mi>f</mi><mo stretchy="false">(</mo><msub><mover accent="true"><mi mathvariant="bold-italic">x</mi><mo stretchy="true">~</mo></mover><mi>i</mi></msub><mo stretchy="false">)</mo><mo>=</mo><mi>R</mi><mi>e</mi><mi>s</mi><mi>N</mi><mi>e</mi><mi>t</mi><mo stretchy="false">(</mo><msub><mover accent="true"><mi mathvariant="bold-italic">x</mi><mo stretchy="true">~</mo></mover><mi>i</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\boldsymbol{h}_i = f(\widetilde {\boldsymbol{x}}_i)=ResNet(\widetilde {\boldsymbol{x}}_i)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord"><span class="mord"><span class="mord boldsymbol">h</span></span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord"><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7044em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord boldsymbol">x</span></span></span></span><span class="svg-align" style="top:-3.4444em;"><span class="pstrut" style="height:3em;"></span><span style="height:0.26em;"><svg xmlns="http://www.w3.org/2000/svg" width='100%' height='0.26em' viewBox='0 0 600 260' preserveAspectRatio='none'><path d='M200 55.538c-77 0-168 73.953-177 73.953-3 0-7-2.175-9-5.437L2 97c-1-2-2-4-2-6 0-4 2-7 5-9l20-12C116 12 171 0 207 0c86 0 114 68 191 68 78 0 168-68 177-68 4 0 7 2 9 5l12 19c1 2.175 2 4.35 2 6.525 0 4.35-2 7.613-5 9.788l-19 13.05c-92 63.077-116.937 75.308-183 76.128-68.267.847-113-73.952-191-73.952z'/></svg></span></span></span></span></span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mord mathnormal">es</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mord mathnormal">e</span><span class="mord mathnormal">t</span><span class="mopen">(</span><span class="mord"><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7044em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord boldsymbol">x</span></span></span></span><span class="svg-align" style="top:-3.4444em;"><span class="pstrut" style="height:3em;"></span><span style="height:0.26em;"><svg xmlns="http://www.w3.org/2000/svg" width='100%' height='0.26em' viewBox='0 0 600 260' preserveAspectRatio='none'><path d='M200 55.538c-77 0-168 73.953-177 73.953-3 0-7-2.175-9-5.437L2 97c-1-2-2-4-2-6 0-4 2-7 5-9l20-12C116 12 171 0 207 0c86 0 114 68 191 68 78 0 168-68 177-68 4 0 7 2 9 5l12 19c1 2.175 2 4.35 2 6.525 0 4.35-2 7.613-5 9.788l-19 13.05c-92 63.077-116.937 75.308-183 76.128-68.267.847-113-73.952-191-73.952z'/></svg></span></span></span></span></span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> ，这里的 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi mathvariant="bold-italic">h</mi><mi>i</mi></msub><mo>∈</mo><msup><mi mathvariant="double-struck">R</mi><mi>d</mi></msup></mrow><annotation encoding="application/x-tex">\boldsymbol{h}_i \in \mathbb R^d</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord"><span class="mord"><span class="mord boldsymbol">h</span></span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8491em;"></span><span class="mord"><span class="mord mathbb">R</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">d</span></span></span></span></span></span></span></span></span></span></span> 是经过了平均池化层后的输出。</li><li>使用已将小型的神经网络projection head <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>g</mi><mo stretchy="false">(</mo><mo>⋅</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">g(\cdot)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mopen">(</span><span class="mord">⋅</span><span class="mclose">)</span></span></span></span> 将表示映射到使用的对比损失空间中。这里使用了具有一层隐藏层的<strong>MLP</strong>去映射：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi mathvariant="bold-italic">z</mi><mi>i</mi></msub><mo>=</mo><mi>g</mi><mo stretchy="false">(</mo><msub><mi mathvariant="bold-italic">h</mi><mi>i</mi></msub><mo stretchy="false">)</mo><mo>=</mo><msup><mi>W</mi><mrow><mo stretchy="false">(</mo><mn>2</mn><mo stretchy="false">)</mo></mrow></msup><mi>σ</mi><mo stretchy="false">(</mo><msup><mi>W</mi><mrow><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow></msup><msub><mi mathvariant="bold-italic">h</mi><mi>i</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\boldsymbol z_i = g(\boldsymbol h_i) = W^{(2)} \sigma(W^{(1)} \boldsymbol h_i)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5944em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord"><span class="mord"><span class="mord boldsymbol" style="margin-right:0.04213em;">z</span></span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mopen">(</span><span class="mord"><span class="mord"><span class="mord"><span class="mord boldsymbol">h</span></span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.138em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.888em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mtight">2</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span><span class="mord mathnormal" style="margin-right:0.03588em;">σ</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.888em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mtight">1</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span><span class="mord"><span class="mord"><span class="mord"><span class="mord boldsymbol">h</span></span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> 。像第四部分说的，相比于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi mathvariant="bold-italic">h</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">\boldsymbol h_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord"><span class="mord"><span class="mord boldsymbol">h</span></span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> ，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi mathvariant="bold-italic">z</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">\boldsymbol z_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5944em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord"><span class="mord"><span class="mord boldsymbol" style="margin-right:0.04213em;">z</span></span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 能更好的定于对比损失。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;A-Simple-Framework-for-Contrastive-Learning-of-Visual-Representations-SimCLR&quot;&gt;A Simple Framework for Contrastive Learning of Visual </summary>
      
    
    
    
    <category term="论文阅读" scheme="http://example.com/categories/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/"/>
    
    
    <category term="对比学习" scheme="http://example.com/tags/%E5%AF%B9%E6%AF%94%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="无监督" scheme="http://example.com/tags/%E6%97%A0%E7%9B%91%E7%9D%A3/"/>
    
  </entry>
  
  <entry>
    <title>LC-104.二叉树的最大深度</title>
    <link href="http://example.com/2022/03/31/LC-104%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6/"/>
    <id>http://example.com/2022/03/31/LC-104%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6/</id>
    <published>2022-03-31T03:53:43.335Z</published>
    <updated>2022-04-06T00:49:16.800Z</updated>
    
    <content type="html"><![CDATA[<h2 id="LC-104-二叉树的最大深度"><a href="https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/">LC-104.二叉树的最大深度</a></h2><p>这道题是一道简单题，可以使用递归法和迭代法进行求解。</p><h2 id="迭代法">迭代法</h2><p>迭代法最好就使用队列进行层序遍历，这样每遍历一层，深度+1：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxDepth</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        depth = <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line">        que = deque([root])</span><br><span class="line">        <span class="keyword">while</span> que:</span><br><span class="line">            depth += <span class="number">1</span></span><br><span class="line">            size = <span class="built_in">len</span>(que)</span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(size):</span><br><span class="line">                cur = que.popleft()</span><br><span class="line">                <span class="keyword">if</span> cur.left: que.append(cur.left)</span><br><span class="line">                <span class="keyword">if</span> cur.right: que.append(cur.right)</span><br><span class="line">        <span class="keyword">return</span> depth</span><br></pre></td></tr></table></figure><h2 id="递归法">递归法</h2><p>递归法这部分其实可以分为前序遍历（中左右），也可以使用后序遍历（左右中）。使用前序求的就是深度，使用后序求的是高度，<strong>而根节点的高度就是二叉树的最大深度</strong>。</p><ul><li><strong>前序（中左右）</strong></li></ul><p>前序其实就是在递归之前就已经将本层的深度加进去，然后再进行递归，是从上至下的。这体现出了从上之下逐层递归+1的思想。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def maxDepth(self, root: Optional[TreeNode]) -&gt; int:</span><br><span class="line">        depth = 0</span><br><span class="line">        def digui(root, depth):</span><br><span class="line">        # 这里直接返回了depth，所以上一层递归的时候，不需要额外判断左右孩子是否存在。</span><br><span class="line">            if not root: return depth</span><br><span class="line"></span><br><span class="line">            l_d = digui(root.left, depth + 1)</span><br><span class="line">            r_d = digui(root.right, depth + 1)</span><br><span class="line">            return max(l_d, r_d)</span><br><span class="line"></span><br><span class="line">        return digui(root, depth)</span><br></pre></td></tr></table></figure><ul><li><strong>后序遍历（左右中）</strong></li></ul><p>后序遍历就是每次从下至上的。也就说到最底层后，每次向上一层返回时，再取左右子树最高的高度后+1，这体现出了从下至上的求高度的过程。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxdepth</span>(<span class="params">self, root: treenode</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">return</span> self.getdepth(root)</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getdepth</span>(<span class="params">self, node</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> node:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        leftdepth = self.getdepth(node.left) <span class="comment">#左</span></span><br><span class="line">        rightdepth = self.getdepth(node.right) <span class="comment">#右</span></span><br><span class="line">        depth = <span class="number">1</span> + <span class="built_in">max</span>(leftdepth, rightdepth) <span class="comment">#中</span></span><br><span class="line">        <span class="keyword">return</span> depth</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/maximum-depth-of-n-ary-tree/">559. N 叉树的最大深度</a></p><p>这里有一道类似的题，思想是一样的，只不过递归的时候，因为是N叉树，不是直接递归左右子树，而是用一个循环依次递归children。每次递归用一个tmp记录，然后找到这个tmp最大值(也就是高度最大的子树)，然后加一。</p><p>这里有个需要注意的点，如果某个节点没有子树的话，我们循环的时候就会报错，需要提前判断。如果没有children，直接return 1，而不是0。这是为什么呢，因为后序遍历都是先递归返回后再+1，如果没有children没有子树就不会递归，就没有机会去+1，所以我们应该直接去+1.当然，这也就是说，<strong>我们的返回条件提前了一层，不是去判断这个节点本身是否存在，而是判断他的children是否存在，如果存在则递归，不存在直接return 1， 而不是0。</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxDepth</span>(<span class="params">self, root: <span class="string">&#x27;Node&#x27;</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 使用后序遍历</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">digui</span>(<span class="params">root</span>):</span><br><span class="line">            <span class="comment"># if not root:</span></span><br><span class="line">            <span class="comment">#     return 0</span></span><br><span class="line">            tmp_depth = []</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root.children: <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> child <span class="keyword">in</span> root.children:</span><br><span class="line">                tmp_depth.append(digui(child))</span><br><span class="line">            depth = <span class="number">1</span> + <span class="built_in">max</span>(tmp_depth)</span><br><span class="line">            <span class="keyword">return</span> depth</span><br><span class="line">        <span class="keyword">return</span> digui(root)</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;LC-104-二叉树的最大深度&quot;&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/&quot;&gt;LC-104.二叉树的最大深度&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;这道题是一道简单题，可以使用</summary>
      
    
    
    
    <category term="LeetCode" scheme="http://example.com/categories/LeetCode/"/>
    
    
    <category term="数学规律" scheme="http://example.com/tags/%E6%95%B0%E5%AD%A6%E8%A7%84%E5%BE%8B/"/>
    
  </entry>
  
  <entry>
    <title>如使用清华镜像快速下载</title>
    <link href="http://example.com/2022/03/30/%E5%A6%82%E4%BD%BF%E7%94%A8%E6%B8%85%E5%8D%8E%E9%95%9C%E5%83%8F%E5%BF%AB%E9%80%9F%E4%B8%8B%E8%BD%BD/"/>
    <id>http://example.com/2022/03/30/%E5%A6%82%E4%BD%BF%E7%94%A8%E6%B8%85%E5%8D%8E%E9%95%9C%E5%83%8F%E5%BF%AB%E9%80%9F%E4%B8%8B%E8%BD%BD/</id>
    <published>2022-03-30T09:02:35.342Z</published>
    <updated>2022-03-30T09:06:27.607Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题背景">问题背景</h2><p>平时安装一些python包的过程中，总会面临安装下载过慢，<code>time out</code>的情况，今天提供一个方法能够快速安装包。首先介绍一下官网提供的方法。</p><h2 id="官网下载方法">官网下载方法</h2><p>这里以下载dgl为例、</p><ul><li>首先去<a href="https://www.dgl.ai/pages/start.html">dgl官网</a>，点击install，可以看到如下界面：</li></ul><p><img src="https://raw.githubusercontent.com/zhiqiang00/Picbed/main/blog-images/2022/03/30/e36ad8f3b33917db693979345b1be384-image-20220330163854997-89a580.png" alt="image-20220330163854997"></p><ul><li><p>根据你的服务器or电脑的配置选择相关配置，然后在命令行里面输入Run this 的代码。这里以linux为例，输入<code>nvidia-smi</code>查看自己的cuda的版本(这里如果你有自己的虚拟环境，记得使用 <code>conda activate xxx</code> 激活)，如下：</p><p><img src="https://raw.githubusercontent.com/zhiqiang00/Picbed/main/blog-images/2022/03/30/32e8629551399304dc26382b1503bdda-image-20220330164252219-8eaab4.png" alt="image-20220330164252219"></p><p>一般情况下，<strong>使用这种办法容易碰到time out</strong>的错误，原因就是网络不稳定造成的。这时候我们考虑使用清华镜像。</p><p><img src="https://raw.githubusercontent.com/zhiqiang00/Picbed/main/blog-images/2022/03/30/5f112d7872fc3224accbaa46d32b3c6a-image-20220330164528766-57aaf3.png" alt="image-20220330164528766"></p></li></ul><h2 id="使用清华镜像">使用清华镜像</h2><p>在使用清华镜像的时候，我们一般就是使用<code>pip install package -i https://pypi.tuna.tsinghua.edu.cn/simple </code> 这样的方式，下载，但是有时候我们会碰到如下的报错：</p><p><img src="https://raw.githubusercontent.com/zhiqiang00/Picbed/main/blog-images/2022/03/30/802b1155b5987b0f49c4cd4a8a6d917b-image-20220330165208169-4163c0.png" alt="image-20220330165208169"></p><p>这个错误的原因是因为在清华镜像源中，没有和我们想要的包的名字相同。这时我们需要进入到<a href="https://pypi.tuna.tsinghua.edu.cn/simple/">镜像</a>中，<code>ctrl + F</code>检索我们要的包，找到一个和我们的版本相近似的或者和cuda兼容的包：</p><p><img src="https://raw.githubusercontent.com/zhiqiang00/Picbed/main/blog-images/2022/03/30/587e27a44c9afd4273b4da8f796f3940-image-20220330165116062-ebb0aa.png" alt="image-20220330165116062"></p><p>然后，重新下载(这里以dgl-cu111为例)，输入命令<code>pip install dgl-cu111 dglgo  -i https://pypi.tuna.tsinghua.edu.cn/simple</code> :</p><p><img src="https://raw.githubusercontent.com/zhiqiang00/Picbed/main/blog-images/2022/03/30/e3842c9d275500e9768a6bcf6e6a6bfc-image-20220330165553413-579e26.png" alt="image-20220330165553413"></p><p>然后就可以快速下载啦~</p><blockquote><p><a href="https://blog.csdn.net/qq_43351000?type=blog">欢迎关注我的CSDN个人博客~</a></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;问题背景&quot;&gt;问题背景&lt;/h2&gt;
&lt;p&gt;平时安装一些python包的过程中，总会面临安装下载过慢，&lt;code&gt;time out&lt;/code&gt;的情况，今天提供一个方法能够快速安装包。首先介绍一下官网提供的方法。&lt;/p&gt;
&lt;h2 id=&quot;官网下载方法&quot;&gt;官网下载方法&lt;/</summary>
      
    
    
    
    <category term="python，linux" scheme="http://example.com/categories/python%EF%BC%8Clinux/"/>
    
    
    <category term="python，linux" scheme="http://example.com/tags/python%EF%BC%8Clinux/"/>
    
  </entry>
  
  <entry>
    <title>LC-101.对称二叉树</title>
    <link href="http://example.com/2022/03/30/LC-101%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>http://example.com/2022/03/30/LC-101%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91/</id>
    <published>2022-03-30T07:30:58.488Z</published>
    <updated>2022-04-06T00:25:01.025Z</updated>
    
    <content type="html"><![CDATA[<h2 id="LC-101-对称二叉树"><a href="https://leetcode-cn.com/problems/symmetric-tree/">LC-101.对称二叉树</a></h2><h2 id="递归法">递归法</h2><p>使用递归的时候，主要思想是将根节点下面左右子树分别同时递归，然后在递归过程中进行比较，需要注意的时，比较的时候，应该是同层的 <strong>n1.left 和 n2.right</strong>  以及  <strong>n1.right 和 n2.left</strong> 进行比较，最后如果这两个比较同时为True，那么该层的递归返回True。(<strong>这里之所以这样比较，是因为这是判断中心轴对称问题</strong>)</p><p>按照递归三部曲</p><ol><li><p>确定递归函数的参数和返回值</p><p>这里比较根节点的两个子树，所以输入函数的应该是两个子树。返回值，就是是否该层递归比较的结果</p></li><li><p>确定终止条件、</p><p>这里是重点，之所以说这里是重点，是因为如果不处理好终止条件，就没办法控制节点为空的情况，那么后面数值比较的时候就会出现空指针的问题。</p><p><strong>节点有空的情况有：</strong></p></li></ol><ul><li><p>左边空，右边不空，不对称，return False</p></li><li><p>左边不空，右边空，不对称，return False</p></li><li><p>左右都空，对称，return True</p><p><strong>节点不空的情况(排除了上面为空的情况，下面就是都不空了)：</strong></p><p>左右都不空，如果val不相等，不那么return False。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> left == <span class="literal">None</span> <span class="keyword">and</span> right != <span class="literal">None</span>: <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"><span class="keyword">elif</span> left != <span class="literal">None</span> <span class="keyword">and</span> right == <span class="literal">None</span>: <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"><span class="keyword">elif</span> left == <span class="literal">None</span> <span class="keyword">and</span> right == <span class="literal">None</span>: <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"><span class="comment">#排除了空节点，再排除数值不相同的情况</span></span><br><span class="line"><span class="keyword">elif</span> left.val != right.val: <span class="keyword">return</span> <span class="literal">False</span>    </span><br></pre></td></tr></table></figure><p>这里可以看到我们最后一个用的是elif而不是else，**在这之后，就只有左右不为空并且数值相同了。**所以在这个节点判断完了之后，我们才可以进行单层递归，否则这里就直接返回了。换句话说，只有本层确定是可以了，我们才继续递归，同时对本层的比较不再额外return，本层的return用来返回本层四个节点的两两比较(n1.left 和 n2.right  以及  n1.right 和 n2.left)。</p></li></ul><ol start="3"><li><p>确定单层递归的逻辑</p><p>单层递归的逻辑就是处理 左右节点都不为空，且数值相同的情况</p><p>也就是在递归的时候，比较n1.left 和 n2.right  以及  n1.right 和 n2.left，并分别返回bool值，如果都对此则return True，否则 False</p><p>这里可以理解为最后将两个结果进行比较的时候，在进行左右子树的根节点的处理，于是整个过程退化近似后序遍历。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">outside = self.compare(left.left, right.right) <span class="comment">#左子树：左、 右子树：右</span></span><br><span class="line">inside = self.compare(left.right, right.left) <span class="comment">#左子树：右、 右子树：左</span></span><br><span class="line">isSame = outside <span class="keyword">and</span> inside <span class="comment">#左子树：中、 右子树：中 （逻辑处理）</span></span><br></pre></td></tr></table></figure></li></ol><p>迭代法使用了一个小的技巧，就是每次使用一个容器把两边的节点同时加入到这个容器当中，然后进行比较就好了，这个容器可以是<strong>队列</strong>也可以是<strong>栈</strong>。</p><ul><li><p>在每次取出两个节点进行比较的时候：</p><ul><li>判断是否同时为空，如果是，则是对称的，并且不需要添加新的节点了，所以用continue。</li><li>如果上面判断后，如果两个节点有一个为空，或者都不为空但是数值不同，那么return False</li></ul></li><li><p>最后，交叉加入新的节点，具体如下(和上面所提一样)：</p><ul><li>queue.append(leftNode.left) #加入左节点左孩子</li><li>queue.append(rightNode.right) #加入右节点右孩子</li><li>queue.append(leftNode.right) #加入左节点右孩子</li><li>queue.append(rightNode.left) #加入右节点左孩子</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> collections</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isSymmetric</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        queue = collections.deque()</span><br><span class="line">        queue.append(root.left) <span class="comment">#将左子树头结点加入队列</span></span><br><span class="line">        queue.append(root.right) <span class="comment">#将右子树头结点加入队列</span></span><br><span class="line">        <span class="keyword">while</span> queue: <span class="comment">#接下来就要判断这这两个树是否相互翻转</span></span><br><span class="line">            leftNode = queue.popleft()</span><br><span class="line">            rightNode = queue.popleft()</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> leftNode <span class="keyword">and</span> <span class="keyword">not</span> rightNode: <span class="comment">#左节点为空、右节点为空，此时说明是对称的</span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">#左右一个节点不为空，或者都不为空但数值不相同，返回false</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> leftNode <span class="keyword">or</span> <span class="keyword">not</span> rightNode <span class="keyword">or</span> leftNode.val != rightNode.val:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            queue.append(leftNode.left) <span class="comment">#加入左节点左孩子</span></span><br><span class="line">            queue.append(rightNode.right) <span class="comment">#加入右节点右孩子</span></span><br><span class="line">            queue.append(leftNode.right) <span class="comment">#加入左节点右孩子</span></span><br><span class="line">            queue.append(rightNode.left) <span class="comment">#加入右节点左孩子</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure><h2 id="迭代法-栈">迭代法(栈)</h2><p>就是换了一个容器，直接将队列换成栈就可以啦~</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;LC-101-对称二叉树&quot;&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/symmetric-tree/&quot;&gt;LC-101.对称二叉树&lt;/a&gt;&lt;/h2&gt;
&lt;h2 id=&quot;递归法&quot;&gt;递归法&lt;/h2&gt;
&lt;p&gt;使用递归的时候，主要思想</summary>
      
    
    
    
    <category term="LeetCode" scheme="http://example.com/categories/LeetCode/"/>
    
    
    <category term="二叉树" scheme="http://example.com/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>Competition06-模型融合</title>
    <link href="http://example.com/2022/03/28/Competition06-%E6%A8%A1%E5%9E%8B%E8%9E%8D%E5%90%88/"/>
    <id>http://example.com/2022/03/28/Competition06-%E6%A8%A1%E5%9E%8B%E8%9E%8D%E5%90%88/</id>
    <published>2022-03-28T07:40:41.926Z</published>
    <updated>2022-04-01T08:45:49.329Z</updated>
    
    <content type="html"><![CDATA[<h2 id="模型融合">模型融合</h2><p>模型融合，也叫做集成学习，将不同模型的优点进行结合。下面介绍了怎么产生有差异性的模型，然后介绍两种模型融合的方式：</p><h3 id="1-构建多样性">1. 构建多样性</h3><p>多样性是指子模型之间存在差异，可以通过降低子模型的同质性来构建多样性。</p><h4 id="1-1-特征多样性">1.1 特征多样性</h4><p>构建多个有差异的特征集并分别进行建模，可以使特征存在不同的超空间，从而使多个模型有不同的泛化能力。实践中，不同队友之间的特征集往往是不一样的，直接进行模型融合一般会有一定提升。</p><p>随机森林、XGBoost和LightGBM这三个里面都有参数可以设置，其实就是构建特征的多样性。</p><h4 id="1-2-样本多样性">1.2 样本多样性</h4><p>样本多样性是将数据集切分为多份，然后进行分别建模。有时候切分数据集不是随意的，而是根据具体的赛题，最大限度并且合理的去切分数据集，从而既能保证多样性，还能更好的让模型捕获不同方面的数据特征。</p><h4 id="1-3-模型多样性">1.3 模型多样性</h4><p>不同模型对数据的表达能力是不同的：</p><ul><li>FM能够学习到特征之间的交叉信息，并且记忆力较强；</li><li>树模型可以很好的处理连续特征和离散特征(LightGBM和CatBoost)，并且对异常值也具有较好的健壮性。</li><li>传统的树模型和神经网络也需要尝试，并进行融合。</li></ul><p>处理上述方法，还可以<strong>训练目标多样性</strong>、<strong>参数多样性</strong>和<strong>损失函数多样性</strong>。</p><h3 id="2-训练过程融合">2. 训练过程融合</h3><p>训练过程融合的模型包括随机森林和XGBoost，这两个模型都是在训练中构造多个决策树进行融合。</p><p>其中，<strong>随机森林通过Bagging的方式</strong>，<strong>XGBoost通过Boosting的方式</strong>进行融合。</p><h3 id="3-训练结果融合">3. 训练结果融合</h3><p>主要包括加权法，Stacking和Blending。结果融合的方式选择和具体的赛题和评价规则有很大的关系。</p><h4 id="3-1-加权法">3.1 加权法</h4><p>针对一系列任务（比如分类和回归）和评价指标（如AUC，MSE和Logloss）都是有效的。</p><p>具体做法是有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span> 个算法模型并都预测了结果，直接对着 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span> 个结果取平均值或者给予每个算法不同的权重然后加权求和，记得到了融合结果。</p><p>这个方法，通常可以减少过拟合，因为每个模型有一定的噪音；同时，可以平滑噪声，提高模型泛化能力。</p><ul><li><p><strong>分类问题</strong></p><p>输出是one-hot类型，可以使用加权加或者投票法。</p></li><li><p><strong>回归问题</strong></p><p>针对结果可以考虑使用<strong>加权法</strong>、<strong>算数平均</strong>和<strong>几何平均</strong>，这个和不同的赛题设置的评分规则有关系。</p><p>2019年腾讯广告大赛中，评分规则是对称平均绝对百分比误差(SMAPE)，这个规则越小的值对评分影响越大，而算是平均会导致结果偏大，所以选择<strong>几何平均</strong>。</p></li><li><p><strong>排序问题</strong></p></li></ul><h4 id="3-2-Stacking融合">3.2 Stacking融合</h4><p>为了解决加权法需要人工确定权重的问题，使用一个新的模型来学习每个分类器的权重。这就是Stacking的融合思想。</p><p>注意：</p><ul><li>构建的新的模型一般是简单模型，比如逻辑回归线性模型；</li><li>使用多个模型斤进行Stacking融合会有比较好的结果。</li></ul><p>详细介绍在参考文献。</p><h4 id="3-3-Blending融合">3.3 Blending融合</h4><p>见参考文献</p><blockquote><p><strong>参考文献</strong></p><ol><li><a href="https://zhuanlan.zhihu.com/p/25836678">【机器学习】模型融合方法概述</a></li><li><a href="https://zhuanlan.zhihu.com/p/26890738">Kaggle机器学习之模型融合（stacking）心得</a></li><li><a href="https://blog.csdn.net/sinat_35821976/article/details/83622594">图解Blending&amp;Stacking</a></li><li><a href="https://blog.csdn.net/sinat_35821976/article/details/89845588">从零实现机器学习算法(七) Blending</a></li></ol></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;模型融合&quot;&gt;模型融合&lt;/h2&gt;
&lt;p&gt;模型融合，也叫做集成学习，将不同模型的优点进行结合。下面介绍了怎么产生有差异性的模型，然后介绍两种模型融合的方式：&lt;/p&gt;
&lt;h3 id=&quot;1-构建多样性&quot;&gt;1. 构建多样性&lt;/h3&gt;
&lt;p&gt;多样性是指子模型之间存在差异，可以</summary>
      
    
    
    
    <category term="竞赛" scheme="http://example.com/categories/%E7%AB%9E%E8%B5%9B/"/>
    
    
    <category term="模型融合" scheme="http://example.com/tags/%E6%A8%A1%E5%9E%8B%E8%9E%8D%E5%90%88/"/>
    
  </entry>
  
  <entry>
    <title>我的本科经历</title>
    <link href="http://example.com/2022/03/28/%E6%9C%AC%E7%A7%91%E7%BB%8F%E5%8E%86/"/>
    <id>http://example.com/2022/03/28/%E6%9C%AC%E7%A7%91%E7%BB%8F%E5%8E%86/</id>
    <published>2022-03-28T05:53:29.000Z</published>
    <updated>2022-03-30T14:05:45.554Z</updated>
    
    <content type="html"><![CDATA[<p>最近有低年级学弟学妹参加相关夏令营，想参考一下我的建立，为例增加一下我的访问量，遂将cv传到博客来，哈哈哈哈~</p><iframe src="cv.pdf#toolbar=0." width="800px" height="1210px" frameborder="0" scrolling="no"></iframe>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;最近有低年级学弟学妹参加相关夏令营，想参考一下我的建立，为例增加一下我的访问量，遂将cv传到博客来，哈哈哈哈~&lt;/p&gt;
&lt;iframe src=&quot;cv.pdf#toolbar=0.&quot; width=&quot;800px&quot; height=&quot;1210px&quot; frameborder=&quot;0&quot;</summary>
      
    
    
    
    
  </entry>
  
</feed>
